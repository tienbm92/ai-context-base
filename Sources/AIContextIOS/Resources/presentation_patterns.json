{
  "$schema": "https://json-schema.org/draft-07/schema",
  "id": "ios.presentation_patterns.v2",
  "version": "2.0.0",
  "last_updated": "2025-10-30",
  
  "primary_pattern": "MVVM (Model-View-ViewModel)",
  "_comment": "MVVM for AI-driven code generation. CRITICAL: Animation in @State (View), NOT ViewModel transient UI state",
  
  "mvvm_overview": {
    "description": "Unidirectional-ish data flow with ViewModels exposing observable state",
    "components": ["State", "Action", "ViewModel", "Environment", "View"],
    "data_flow": "User interaction → ViewModel method/API → ViewModel updates state → View refresh",
    "library": "native Swift + Combine/Swift Concurrency (no external lib required)",
    "benefits_for_ai": [
      "Explicit state structures (no implicit mutations)",
      "Clear ViewModel methods (intent handlers)",
      "Deterministic state updates (pure-ish methods + injected UseCases)",
      "Protocol-based dependencies (clear injection points)",
      "Testable via unit tests for ViewModels (XCTest + mocks)"
    ],
    "key_principle": "Animation state in @State (View), Business state in ViewModel@Published properties"
  },
  
  "state_component": {
    "definition": "struct {Feature}State: Equatable",
    "purpose": "Immutable value type containing ALL business state for a feature",
    "must_rules": [
      "Be struct (value semantics)",
      "Conform to Equatable",
      "Contain business state ONLY (no UI/animation transient state)"
    ],
    "must_not_rules": [
      "Contain animation values (CGFloat/Double/Angle)",
      "Contain transient UI state (@State-like properties)",
      "Import UIKit or SwiftUI (pure Swift only)"
    ],
    "forbidden_properties": [
      "var animationProgress: CGFloat",
      "var buttonScale: Double",
      "var dragOffset: CGPoint",
      "var shakeOffset: Double"
    ],
    "correct_example": "struct LoginState: Equatable {\n  var email: String = \"\"\n  var password: String = \"\"\n  var status: Status = .idle\n  var errorMessage: String?\n  \n  enum Status: Equatable {\n    case idle\n    case loading\n    case success(User)\n    case error\n  }\n  \n  var isFormValid: Bool {\n    !email.isEmpty && email.contains(\"@\") && !password.isEmpty\n  }\n}",
    "wrong_example": "// ❌ WRONG - Contains animation state\nstruct LoginState: Equatable {\n  var email: String = \"\"\n  var buttonScale: CGFloat = 1.0  // ← FORBIDDEN\n  var shakeOffset: Double = 0     // ← FORBIDDEN\n}"
  },
  
  "action_component": {
    "definition": "enum {Feature}Action: Equatable",
    "purpose": "Exhaustive list of ALL possible events (user interactions + system responses)",
    "must_rules": [
      "Be enum (exhaustive)",
      "Cover ALL user interactions",
      "Cover ALL system responses",
      "Use associated values for event data"
    ],
    "must_not_rules": [
      "Have generic cases (.update, .setState)",
      "Skip system response cases"
    ],
    "naming_patterns": {
      "user_input": ".{field}Changed(Value)",
      "user_action": ".{element}{Action}",
      "system_response": ".{action}Response(Result<T, Error>)",
      "navigation": ".navigateTo{Destination}"
    },
    "example": "enum LoginAction: Equatable {\n  // User inputs\n  case emailChanged(String)\n  case passwordChanged(String)\n  \n  // User actions\n  case loginButtonTapped\n  case registerButtonTapped\n  \n  // System responses\n  case loginResponse(Result<User, APIError>)\n  \n  // Navigation\n  case navigateToHome\n}"
  },
  
  "viewmodel_component": {
    "definition": "class {Feature}ViewModel: ObservableObject",
    "signature": "class {Feature}ViewModel: ObservableObject { @Published var state: State; func send(_ action: Action) async }",
    "purpose": "Object that owns business state, exposes intents, and invokes UseCases for side effects",
    "must_rules": [
      "Handle ALL intent cases via methods",
      "Update @Published state properties",
      "Perform async work via async/await or Combine",
      "Keep side effects in UseCases when possible"
    ],
    "must_not_rules": [
      "Hold transient UI/animation state (use View @State)",
      "Directly perform platform/UI side effects",
      "Leak implementation details to View"
    ],
    "example": "class LoginViewModel: ObservableObject {\n  @Published private(set) var state = LoginState()\n  private let loginUseCase: LoginUserUseCaseProtocol\n\n  init(loginUseCase: LoginUserUseCaseProtocol) {\n    self.loginUseCase = loginUseCase\n  }\n\n  @MainActor func send(_ action: LoginAction) async {\n    switch action {\n    case .emailChanged(let email):\n      state.email = email\n    case .loginButtonTapped:\n      guard state.isFormValid else {\n        state.errorMessage = \"Invalid form\"\n        return\n      }\n      state.status = .loading\n      do {\n        let user = try await loginUseCase.execute(email: state.email, password: state.password)\n        state.status = .success(user)\n      } catch {\n        state.status = .error\n        state.errorMessage = error.localizedDescription\n      }\n    default: break\n    }\n  }\n}"
  },
  
  "environment_component": {
    "definition": "struct {Feature}Environment",
    "purpose": "Container for ALL dependencies (UseCases, services, schedulers)",
    "must_rules": [
      "Be struct with dependency properties",
      "Inject UseCases (NOT Repositories)",
      "Include mainQueue scheduler",
      "Provide static .mock for testing"
    ],
    "example": "struct LoginEnvironment {\n  var loginUseCase: LoginUserUseCaseProtocol\n  var analyticsService: AnalyticsServiceProtocol\n  var mainQueue: DispatchQueue\n  \n  static var mock: Self {\n    Self(\n      loginUseCase: MockLoginUseCase(),\n      analyticsService: MockAnalytics(),\n      mainQueue: .immediate\n    )\n  }\n  \n  static var live: Self {\n    Self(\n      loginUseCase: Resolver.resolve(),\n      analyticsService: Resolver.resolve(),\n      mainQueue: .main\n    )\n  }\n}"
  },
  
  "view_component": {
    "framework": "SwiftUI",
    "pattern": "ViewModel (ObservableObject + @Published) observed by View via @StateObject/@ObservedObject",
    "critical_rule": "Animation state in @State (View), Business state in ViewModel",
    "must_rules": [
      "Use a ViewModel property (class conforming to ObservableObject)",
      "Observe it with @StateObject when the View owns it or @ObservedObject when injected",
      "Use @State for UI/animation transient state",
      "Invoke ViewModel methods for intents",
      "Use .onChange(of:) to trigger animations"
    ],
    "must_not_rules": [
      "Contain business logic",
      "Call UseCases directly",
      "Put animation state in ViewModel state"
    ],
    "animation_pattern": {
      "principle": "Business state change → .onChange() → @State animation",
      "flow": "ViewModel state updates → View.onChange() detects → withAnimation {} updates @State → SwiftUI animates"
    },
    "example": "struct LoginView: View {\n  @StateObject private var viewModel = LoginViewModel(loginUseCase: Resolver.resolve())\n  \n  // ✅ Animation state in @State\n  @State private var isShaking = false\n  @State private var buttonScale: CGFloat = 1.0\n  \n  var body: some View {\n    VStack(spacing: 24) {\n      TextField(\"Email\", text: Binding(\n        get: { viewModel.state.email },\n        set: { viewModel.state.email = $0 }\n      ))\n      \n      Button(\"Login\") {\n        Task { await viewModel.send(.loginButtonTapped) }\n      }\n      .scaleEffect(buttonScale)\n      .disabled(viewModel.state.status == .loading)\n      .modifier(ShakeEffect(shakes: isShaking ? 3 : 0))\n    }\n    // ✅ Business state → animation trigger\n    .onChange(of: viewModel.state.status) { status in\n      switch status {\n      case .loading:\n        withAnimation(.easeInOut(duration: 0.15)) {\n          buttonScale = 0.95\n        }\n      case .error:\n        withAnimation(.default) {\n          isShaking = true\n        }\n        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {\n          isShaking = false\n        }\n      default:\n        buttonScale = 1.0\n      }\n    }\n  }"
  },
  
  "navigation_patterns": {
    "description": "MVVM uses ViewModel-injected callbacks or Coordinator/Navigator patterns for navigation",
    "environment_callbacks": {
      "when": "Simple linear flows",
      "example": "struct LoginEnvironment {\n  var loginUseCase: LoginUserUseCaseProtocol\n  var onLoginSuccess: (User) -> Void\n  var mainQueue: DispatchQueue\n}\n\n// Example: call onLoginSuccess in ViewModel after successful login"
    },
    "navigation_state": {
      "when": "Modals, sheets, alerts",
      "example": "struct DashboardState: Equatable {\n  var destination: Destination?\n  \n  enum Destination: Equatable {\n    case taskDetail(SmartTask)\n    case addTask\n  }\n}\n\n// In View: .sheet(item: Binding(get: { viewModel.state.destination }, set: { _ in viewModel.send(.dismissDestination) })) { destination in\n// ... }"
    },
    "coordinator_hybrid": {
      "when": "Complex flows, deep linking",
      "example": "class AuthCoordinator {\n  func showLogin() {\n    let environment = LoginEnvironment(\n      loginUseCase: Resolver.resolve(),\n      onLoginSuccess: { [weak self] user in\n        self?.showHome(user: user)\n      },\n      mainQueue: .main\n    )\n    let viewModel = LoginViewModel(loginUseCase: environment.loginUseCase)\n    let view = LoginView(viewModel: viewModel)\n    let vc = UIHostingController(rootView: view)\n    navigationController.pushViewController(vc, animated: true)\n  }\n}"
    }
  },
  
  "ai_generation_checklist": {
    "state": [
      "✓ Is struct conforming to Equatable",
      "✓ Contains business state ONLY",
      "✓ NO animation values (CGFloat/Double/Angle)",
      "✓ Pure Swift (no UIKit/SwiftUI imports)"
    ],
    "action": [
      "✓ Is enum with exhaustive cases",
      "✓ Covers ALL user interactions",
      "✓ Covers ALL system responses",
      "✓ NO generic actions (.update, .setState)"
    ],
    "viewmodel": [
      "✓ Is class ObservableObject with @Published state",
      "✓ Exposes intent methods",
      "✓ Keeps UI/animation transient state in View",
      "✓ Testable via unit tests"
    ],
    "environment": [
      "✓ Is struct with dependencies",
      "✓ Injects UseCases (NOT Repositories)",
      "✓ Includes mainQueue scheduler",
      "✓ Has static .mock for testing"
    ],
    "view": [
      "✓ Uses ViewModel (ObservableObject)",
      "✓ Observes ViewModel with @StateObject/@ObservedObject",
      "✓ Uses @State for animations",
      "✓ NO business logic",
      "✓ NO animation state in ViewModel state"
    ]
  },
  
  "common_mistakes": [
    "❌ Putting animation state in ViewModel state (60fps jank)",
    "❌ Using generic actions (.update)",
    "❌ Performing side effects directly in ViewModel instead of UseCases",
    "❌ Calling Repositories from ViewModel (use UseCases)",
    "❌ Not making State Equatable"
  ]
}
