{
  "$schema": "https://json-schema.org/draft-07/schema",
  "id": "ios.templates.mvvm_screen.v1",
  "version": "1.0.0",
  "template_name": "MVVM Screen Template",
  "description": "Complete MVVM feature with State, Action, ViewModel, Environment, and View",

  "_usage": "AI should generate the ViewModel, State, Environment, and View for a feature. CRITICAL: Animation state in @State (View), NOT ViewModel.",

  "file_structure": {
    "description": "4-5 files per feature (State, Action, ViewModel, Environment, View)",
    "files": [
      "{Feature}State.swift",
      "{Feature}Action.swift",
      "{Feature}ViewModel.swift",
      "{Feature}Environment.swift",
      "{Feature}View.swift"
    ],
    "location": "Features/{Feature}/Presentation/{Screen}/"
  },

  "state_template": {
    "filename": "{Feature}State.swift",
    "code": "import Foundation\n\n// MARK: - {Feature}State\n\n/// State for {Feature} feature\n/// CRITICAL: Contains business state ONLY. NO animation values (CGFloat/Double/Angle).\nstruct {Feature}State: Equatable {\n  // MARK: - Properties\n  \n  /// Current status of the feature\n  var status: Status = .idle\n  \n  /// Error message if any\n  var errorMessage: String?\n  \n  // MARK: - Nested Types\n  \n  /// Feature status enum\n  enum Status: Equatable {\n    case idle\n    case loading\n    case loaded\n    case error\n  }\n  \n  // MARK: - Computed Properties\n  \n  /// Whether the feature is currently loading\n  var isLoading: Bool {\n    status == .loading\n  }\n}\n\n// MARK: - Example with Domain Entity\n\n/*\nstruct LoginState: Equatable {\n  var email: String = \"\"\n  var password: String = \"\"\n  var status: Status = .idle\n  var errorMessage: String?\n  var user: User?\n  \n  enum Status: Equatable {\n    case idle\n    case loading\n    case success(User)\n    case error\n  }\n  \n  var isFormValid: Bool {\n    !email.isEmpty && email.contains(\"@\") && !password.isEmpty\n  }\n  \n  var isLoading: Bool {\n    if case .loading = status { return true }\n    return false\n  }\n}\n*/"
  },

  "action_template": {
    "filename": "{Feature}Action.swift",
    "code": "import Foundation\n\n// MARK: - {Feature}Action\n\n/// All possible actions (intents) for {Feature} feature\n/// MUST be exhaustive - cover all user interactions and system responses\nenum {Feature}Action: Equatable {\n  // MARK: - User Interactions\n  \n  /// User tapped the action button\n  case actionButtonTapped\n  \n  // MARK: - System Responses\n  \n  /// Response from async operation\n  case dataResponse(Result<Data, APIError>)\n  \n  // MARK: - Navigation\n  \n  /// Navigate to next screen\n  case navigateToNext\n}\n\n// MARK: - Example with Full Actions\n\n/*\nenum LoginAction: Equatable {\n  // User inputs\n  case emailChanged(String)\n  case passwordChanged(String)\n  case togglePasswordVisibility\n  \n  // User actions\n  case loginButtonTapped\n  case registerButtonTapped\n  case forgotPasswordTapped\n  \n  // System responses\n  case loginResponse(Result<User, APIError>)\n  \n  // Navigation\n  case navigateToHome\n  case navigateToRegister\n  case navigateToForgotPassword\n  \n  // Lifecycle\n  case onAppear\n  case onDisappear\n}\n*/"
  },

  "viewmodel_template": {
    "filename": "{Feature}ViewModel.swift",
    "code": "import Foundation\nimport Combine\n\n// MARK: - {Feature}ViewModel\n\n/// ViewModel for {Feature} feature\n/// CRITICAL: Do not store animation/UI transient values here. Use View @State for animations.\n@MainActor\nclass {Feature}ViewModel: ObservableObject {\n  @Published private(set) var state = {Feature}State()\n  private let fetchDataUseCase: FetchDataUseCaseProtocol\n  private var cancellables = Set<AnyCancellable>()\n\n  init(fetchDataUseCase: FetchDataUseCaseProtocol) {\n    self.fetchDataUseCase = fetchDataUseCase\n  }\n\n  func send(_ action: {Feature}Action) async {\n    switch action {\n    case .actionButtonTapped:\n      state.status = .loading\n      state.errorMessage = nil\n      do {\n        let data = try await fetchDataUseCase.execute()\n        state.status = .loaded\n        // process data into state as needed\n      } catch {\n        state.status = .error\n        state.errorMessage = error.localizedDescription\n      }\n    case .dataResponse(let result):\n      switch result {\n      case .success:\n        state.status = .loaded\n      case .failure(let error):\n        state.status = .error\n        state.errorMessage = error.localizedDescription\n      }\n    case .navigateToNext:\n      // Inform Coordinator/Navigator via callback\n      break\n    }\n  }\n}"
  },

  "environment_template": {
    "filename": "{Feature}Environment.swift",
    "code": "import Foundation\n\n// MARK: - {Feature}Environment\n\n/// Dependencies container for {Feature} feature\n/// MUST inject UseCases (NOT Repositories), include mainQueue scheduler\nstruct {Feature}Environment {\n  // MARK: - UseCases\n  \n  var fetchDataUseCase: FetchDataUseCaseProtocol\n  \n  // MARK: - Services\n  \n  var analyticsService: AnalyticsServiceProtocol\n  var loggerService: LoggerServiceProtocol\n  \n  // MARK: - Schedulers\n  \n  var mainQueue: DispatchQueue\n  \n  // MARK: - Navigation Callbacks (Optional)\n  \n  var onComplete: (() -> Void)?\n  \n  // MARK: - Testing Support\n  \n  /// Mock environment for testing\n  static var mock: Self {\n    Self(\n      fetchDataUseCase: MockFetchDataUseCase(),\n      analyticsService: MockAnalyticsService(),\n      loggerService: MockLoggerService(),\n      mainQueue: .immediate,\n      onComplete: nil\n    )\n  }\n  \n  /// Live environment for production\n  static var live: Self {\n    Self(\n      fetchDataUseCase: Resolver.resolve(),\n      analyticsService: Resolver.resolve(),\n      loggerService: Resolver.resolve(),\n      mainQueue: .main,\n      onComplete: nil\n    )\n  }\n}\n\n// MARK: - Example with Navigation Callbacks\n\n/*\nstruct LoginEnvironment {\n  // UseCases\n  var loginUseCase: LoginUserUseCaseProtocol\n  \n  // Services\n  var analyticsService: AnalyticsServiceProtocol\n  var validationService: ValidationServiceProtocol\n  \n  // Schedulers\n  var mainQueue: DispatchQueue\n  \n  // Navigation\n  var onLoginSuccess: ((User) -> Void)?\n  var onRegisterTapped: (() -> Void)?\n  \n  static var mock: Self {\n    Self(\n      loginUseCase: MockLoginUseCase(),\n      analyticsService: MockAnalyticsService(),\n      validationService: MockValidationService(),\n      mainQueue: .immediate,\n      onLoginSuccess: nil,\n      onRegisterTapped: nil\n    )\n  }\n}\n*/"
  },

  "view_template": {
    "filename": "{Feature}View.swift",
    "code": "import SwiftUI\n\n// MARK: - {Feature}View\n\n/// View for {Feature} feature\n/// CRITICAL: Animation state in @State, Business state in ViewModel\nstruct {Feature}View: View {\n  // MARK: - Properties\n  \n  @StateObject private var viewModel: {Feature}ViewModel\n  \n  // MARK: - Animation State (View-local)\n  // ✅ CORRECT: Animation values in @State\n  \n  @State private var buttonScale: CGFloat = 1.0\n  @State private var isAnimating: Bool = false\n  \n  init(viewModel: {Feature}ViewModel) {\n    _viewModel = StateObject(wrappedValue: viewModel)\n  }\n  \n  // MARK: - Body\n  \n  var body: some View {\n    VStack(spacing: 24) {\n      // Content here\n      \n      Button(\"Action\") {\n        Task { await viewModel.send(.actionButtonTapped) }\n      }\n      .scaleEffect(buttonScale)\n      .disabled(viewModel.state.isLoading)\n      \n      if viewModel.state.isLoading {\n        ProgressView()\n      }\n      \n      if let error = viewModel.state.errorMessage {\n        Text(error)\n          .foregroundColor(.red)\n          .font(.caption)\n      }\n    }\n    .padding()\n    // ✅ CORRECT: Business state change → animation trigger\n    .onChange(of: viewModel.state.status) { status in\n      handleStatusChange(status)\n    }\n  }\n  \n  // MARK: - Private Methods\n  \n  /// Handle status changes with animations\n  private func handleStatusChange(_ status: {Feature}State.Status) {\n    switch status {\n    case .loading:\n      withAnimation(.easeInOut(duration: 0.15)) {\n        buttonScale = 0.95\n      }\n      \n    case .loaded:\n      withAnimation(.spring(response: 0.3)) {\n        buttonScale = 1.0\n      }\n      \n    case .error:\n      buttonScale = 1.0\n      // Trigger shake animation\n      withAnimation(.default) {\n        isAnimating = true\n      }\n      DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {\n        isAnimating = false\n      }\n      \n    case .idle:\n      buttonScale = 1.0\n    }\n  }\n}\n\n// MARK: - Preview\n\n#if DEBUG\nstruct {Feature}View_Previews: PreviewProvider {\n  static var previews: some View {\n    {Feature}View(\n      viewModel: {Feature}ViewModel(fetchDataUseCase: MockFetchDataUseCase())\n    )\n  }\n}\n#endif\n\n// MARK: - Example with Complete View\n\n/*\nstruct LoginView: View {\n  @StateObject private var viewModel = LoginViewModel(loginUseCase: Resolver.resolve())\n  \n  // ✅ Animation state in @State\n  @State private var buttonScale: CGFloat = 1.0\n  @State private var isShaking: Bool = false\n  @State private var showPassword: Bool = false\n  \n  var body: some View {\n    VStack(spacing: 24) {\n      // Email field\n      TextField(\"Email\", text: Binding(\n        get: { viewModel.state.email },\n        set: { viewModel.state.email = $0 }\n      ))\n      .textFieldStyle(.roundedBorder)\n      .autocapitalization(.none)\n      .keyboardType(.emailAddress)\n      \n      // Password field\n      HStack {\n        if showPassword {\n          TextField(\"Password\", text: Binding(\n            get: { viewModel.state.password },\n            set: { viewModel.state.password = $0 }\n          ))\n        } else {\n          SecureField(\"Password\", text: Binding(\n            get: { viewModel.state.password },\n            set: { viewModel.state.password = $0 }\n          ))\n        }\n        \n        Button(action: { showPassword.toggle() }) {\n          Image(systemName: showPassword ? \"eye.slash\" : \"eye\")\n            .foregroundColor(.secondary)\n        }\n      }\n      .textFieldStyle(.roundedBorder)\n      \n      // Login button\n      Button(\"Login\") {\n        Task { await viewModel.send(.loginButtonTapped) }\n      }\n      .buttonStyle(.borderedProminent)\n      .scaleEffect(buttonScale)\n      .disabled(viewModel.state.isLoading || !viewModel.state.isFormValid)\n      .modifier(ShakeEffect(shakes: isShaking ? 3 : 0))\n      \n      if viewModel.state.isLoading {\n        ProgressView()\n      }\n      \n      if let error = viewModel.state.errorMessage {\n        Text(error)\n          .foregroundColor(.red)\n          .font(.caption)\n      }\n      \n      // Register link\n      Button(\"Don't have an account? Sign up\") {\n        Task { await viewModel.send(.registerButtonTapped) }\n      }\n      .font(.footnote)\n    }\n    .padding()\n    .onChange(of: viewModel.state.status) { status in\n      handleStatusChange(status)\n    }\n  }\n  \n  private func handleStatusChange(_ status: LoginState.Status) {\n    switch status {\n    case .loading:\n      withAnimation(.easeInOut(duration: 0.15)) {\n        buttonScale = 0.95\n      }\n      \n    case .success:\n      withAnimation(.spring(response: 0.3)) {\n        buttonScale = 1.1\n      }\n      DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {\n        withAnimation(.default) {\n          buttonScale = 1.0\n        }\n      }\n      \n    case .error:\n      buttonScale = 1.0\n      withAnimation(.default) {\n        isShaking = true\n      }\n      DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {\n        isShaking = false\n      }\n      \n    case .idle:\n      buttonScale = 1.0\n    }\n  }\n}\n\n// Shake animation modifier\nstruct ShakeEffect: GeometryEffect {\n  var shakes: Int\n  \n  var animatableData: CGFloat {\n    get { CGFloat(shakes) }\n    set { shakes = Int(newValue) }\n  }\n  \n  func effectValue(size: CGSize) -> ProjectionTransform {\n    let offset = sin(animatableData * .pi * 2) * 10\n    return ProjectionTransform(\n      CGAffineTransform(translationX: offset, y: 0)\n    )\n  }\n}\n*/"
  },

  "integration_example": {
    "description": "How to integrate MVVM screen in Coordinator or App",
    "coordinator_usage": "class AuthCoordinator {\n  func showLogin() {\n    let environment = LoginEnvironment(\n      loginUseCase: Resolver.resolve(),\n      analyticsService: Resolver.resolve(),\n      validationService: Resolver.resolve(),\n      mainQueue: .main,\n      onLoginSuccess: { [weak self] user in\n        self?.showHome(user: user)\n      },\n      onRegisterTapped: { [weak self] in\n        self?.showRegister()\n      }\n    )\n    \n    let viewModel = LoginViewModel(fetchDataUseCase: environment.fetchDataUseCase)\n    \n    let loginView = LoginView(viewModel: viewModel)\n    let hostingController = UIHostingController(rootView: loginView)\n    \n    navigationController.pushViewController(\n      hostingController,\n      animated: true\n    )\n  }\n}",
    "swiftui_app_usage": "@main\nstruct MyApp: App {\n  var body: some Scene {\n    WindowGroup {\n      LoginView(\n        viewModel: LoginViewModel(fetchDataUseCase: Resolver.resolve())\n      )\n    }\n  }\n}"
  },

  "checklist": {
    "before_generating": [
      "✓ Define business state in State struct (NO animation values)",
      "✓ List ALL actions in Action enum (user + system)",
      "✓ Implement ViewModel with intent methods",
      "✓ Create Environment with UseCases + schedulers",
      "✓ Build View with @State for animations"
    ],
    "validation": [
      "✓ State is struct conforming to Equatable",
      "✓ NO CGFloat/Double/Angle in State (animation values)",
      "✓ Action enum is exhaustive",
      "✓ ViewModel handles intents",
      "✓ Environment has .mock and .live",
      "✓ View uses @State for animations",
      "✓ View observes ViewModel via @StateObject/@ObservedObject"
    ]
  }
}
