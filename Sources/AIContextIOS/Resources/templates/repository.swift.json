{
  "template_type": "repository",
  "description": "Repository protocol (Domain) and implementation (Data)",
  
  "protocol_template": "import Foundation\n\n/// Repository protocol for {{ENTITY}} data access\n/// - Note: This is the Domain layer contract\nprotocol {{ENTITY}}RepositoryProtocol {\n    /// Fetches {{ENTITY}} by ID\n    func get(id: String) async throws -> {{ENTITY}}\n    \n    /// Fetches all {{ENTITY}}s\n    func getAll() async throws -> [{{ENTITY}}]\n    \n    /// Creates new {{ENTITY}}\n    func create(_ entity: {{ENTITY}}) async throws -> {{ENTITY}}\n    \n    /// Updates existing {{ENTITY}}\n    func update(_ entity: {{ENTITY}}) async throws -> {{ENTITY}}\n    \n    /// Deletes {{ENTITY}} by ID\n    func delete(id: String) async throws\n}",
  
  "implementation_template": "import Foundation\n\n/// Concrete implementation of {{ENTITY}}Repository\nclass {{ENTITY}}Repository: {{ENTITY}}RepositoryProtocol {\n    // MARK: - Dependencies\n    private let remoteDataSource: {{ENTITY}}RemoteDataSource\n    private let localDataSource: {{ENTITY}}LocalDataSource\n    private let cachePolicy: CachePolicy\n    \n    // MARK: - Init\n    init(\n        remoteDataSource: {{ENTITY}}RemoteDataSource,\n        localDataSource: {{ENTITY}}LocalDataSource,\n        cachePolicy: CachePolicy = .cacheFirst(ttl: 300)\n    ) {\n        self.remoteDataSource = remoteDataSource\n        self.localDataSource = localDataSource\n        self.cachePolicy = cachePolicy\n    }\n    \n    // MARK: - Repository Methods\n    func get(id: String) async throws -> {{ENTITY}} {\n        // Try cache first\n        if case .cacheFirst(let ttl) = cachePolicy,\n           let cached = try? await localDataSource.get(id: id),\n           !cached.isExpired(ttl: ttl) {\n            return cached.toDomain()\n        }\n        \n        // Fetch from remote\n        let dto = try await remoteDataSource.fetch(id: id)\n        let entity = dto.toDomain()\n        \n        // Update cache\n        try? await localDataSource.save(entity)\n        \n        return entity\n    }\n    \n    func getAll() async throws -> [{{ENTITY}}] {\n        let dtos = try await remoteDataSource.fetchAll()\n        return dtos.map { $0.toDomain() }\n    }\n    \n    func create(_ entity: {{ENTITY}}) async throws -> {{ENTITY}} {\n        let dto = {{ENTITY}}DTO(from: entity)\n        let createdDTO = try await remoteDataSource.create(dto)\n        let created = createdDTO.toDomain()\n        \n        // Save to local\n        try? await localDataSource.save(created)\n        \n        return created\n    }\n    \n    func update(_ entity: {{ENTITY}}) async throws -> {{ENTITY}} {\n        let dto = {{ENTITY}}DTO(from: entity)\n        let updatedDTO = try await remoteDataSource.update(id: entity.id, dto: dto)\n        let updated = updatedDTO.toDomain()\n        \n        // Update local\n        try? await localDataSource.save(updated)\n        \n        return updated\n    }\n    \n    func delete(id: String) async throws {\n        try await remoteDataSource.delete(id: id)\n        try? await localDataSource.delete(id: id)\n    }\n}\n\n// MARK: - Cache Policy\nenum CachePolicy {\n    case networkOnly\n    case cacheOnly\n    case cacheFirst(ttl: TimeInterval)\n    case networkFirst\n}"
}
