{
  "$schema": "https://json-schema.org/draft-07/schema",
  "id": "ios.templates.mvvm_screen.v1",
  "version": "1.0.0",
  "template_name": "MVVM Screen Template",
  "description": "Complete MVVM feature with State, Action, ViewModel, Environment, and View",
  
  "_usage": "AI should generate the ViewModel, State, Environment, and View for a feature. CRITICAL: Animation state in @State (View), NOT ViewModel.",
  
  "file_structure": {
    "description": "5 files per feature screen",
    "files": [
      "{Feature}State.swift",
      "{Feature}Action.swift",
      "{Feature}Reducer.swift",
      "{Feature}Environment.swift",
      "{Feature}View.swift"
    ],
    "location": "Features/{Feature}/Presentation/{Screen}/"
  },
  
  "state_template": {
    "filename": "{Feature}State.swift",
    "code": "import Foundation\n\n// MARK: - {Feature}State\n\n/// State for {Feature} feature\n/// CRITICAL: Contains business state ONLY. NO animation values (CGFloat/Double/Angle).\nstruct {Feature}State: Equatable {\n  // MARK: - Properties\n  \n  /// Current status of the feature\n  var status: Status = .idle\n  \n  /// Error message if any\n  var errorMessage: String?\n  \n  // MARK: - Nested Types\n  \n  /// Feature status enum\n  enum Status: Equatable {\n    case idle\n    case loading\n    case loaded\n    case error\n  }\n  \n  // MARK: - Computed Properties\n  \n  /// Whether the feature is currently loading\n  var isLoading: Bool {\n    status == .loading\n  }\n}\n\n// MARK: - Example with Domain Entity\n\n/*\nstruct LoginState: Equatable {\n  var email: String = \"\"\n  var password: String = \"\"\n  var status: Status = .idle\n  var errorMessage: String?\n  var user: User?\n  \n  enum Status: Equatable {\n    case idle\n    case loading\n    case success(User)\n    case error\n  }\n  \n  var isFormValid: Bool {\n    !email.isEmpty && email.contains(\"@\") && !password.isEmpty\n  }\n  \n  var isLoading: Bool {\n    if case .loading = status { return true }\n    return false\n  }\n}\n*/"
  },
  
  "action_template": {
    "filename": "{Feature}Action.swift",
    "code": "import Foundation\n\n// MARK: - {Feature}Action\n\n/// All possible actions for {Feature} feature\n/// MUST be exhaustive - cover all user interactions and system responses\nenum {Feature}Action: Equatable {\n  // MARK: - User Interactions\n  \n  /// User tapped the action button\n  case actionButtonTapped\n  \n  // MARK: - System Responses\n  \n  /// Response from async operation\n  case dataResponse(Result<Data, APIError>)\n  \n  // MARK: - Navigation\n  \n  /// Navigate to next screen\n  case navigateToNext\n}\n\n// MARK: - Example with Full Actions\n\n/*\nenum LoginAction: Equatable {\n  // User inputs\n  case emailChanged(String)\n  case passwordChanged(String)\n  case togglePasswordVisibility\n  \n  // User actions\n  case loginButtonTapped\n  case registerButtonTapped\n  case forgotPasswordTapped\n  \n  // System responses\n  case loginResponse(Result<User, APIError>)\n  \n  // Navigation\n  case navigateToHome\n  case navigateToRegister\n  case navigateToForgotPassword\n  \n  // Lifecycle\n  case onAppear\n  case onDisappear\n}\n*/"
  },
  
  "reducer_template": {
    "filename": "{Feature}Reducer.swift",
    "code": "import ComposableArchitecture\nimport Foundation\n\n// MARK: - {Feature}Reducer\n\n/// Reducer for {Feature} feature\n/// MUST be pure function - no side effects in body, use Effect for async work\nlet {feature}Reducer = Reducer<{Feature}State, {Feature}Action, {Feature}Environment> {\n  state, action, environment in\n  \n  switch action {\n  // MARK: - User Interactions\n  \n  case .actionButtonTapped:\n    state.status = .loading\n    state.errorMessage = nil\n    \n    return .run { send in\n      await send(\n        .dataResponse(\n          Result {\n            try await environment.fetchDataUseCase.execute()\n          }\n        )\n      )\n    }\n    \n  // MARK: - System Responses\n  \n  case .dataResponse(.success(let data)):\n    state.status = .loaded\n    // Process data\n    return .none\n    \n  case .dataResponse(.failure(let error)):\n    state.status = .error\n    state.errorMessage = error.localizedDescription\n    return .none\n    \n  // MARK: - Navigation\n  \n  case .navigateToNext:\n    // Handled by parent coordinator or Environment callback\n    return .none\n  }\n}\n\n// MARK: - Example with Complete Reducer\n\n/*\nlet loginReducer = Reducer<LoginState, LoginAction, LoginEnvironment> {\n  state, action, environment in\n  \n  switch action {\n  case .emailChanged(let email):\n    state.email = email\n    return .none\n    \n  case .passwordChanged(let password):\n    state.password = password\n    return .none\n    \n  case .togglePasswordVisibility:\n    // Handled in View with @State\n    return .none\n    \n  case .loginButtonTapped:\n    guard state.isFormValid else {\n      state.errorMessage = \"Please fill all fields correctly\"\n      return .none\n    }\n    \n    state.status = .loading\n    state.errorMessage = nil\n    \n    return .run { [email = state.email, password = state.password] send in\n      await send(\n        .loginResponse(\n          Result {\n            try await environment.loginUseCase.execute(\n              email: email,\n              password: password\n            )\n          }\n        )\n      )\n    }\n    \n  case .loginResponse(.success(let user)):\n    state.status = .success(user)\n    state.user = user\n    return .run { send in\n      // Analytics\n      await environment.analytics.track(event: .login)\n      // Navigate after delay\n      try await environment.mainQueue.sleep(for: .milliseconds(500))\n      await send(.navigateToHome)\n    }\n    \n  case .loginResponse(.failure(let error)):\n    state.status = .error\n    state.errorMessage = error.localizedDescription\n    return .none\n    \n  case .navigateToHome:\n    return .fireAndForget {\n      environment.onLoginSuccess?()\n    }\n    \n  case .onAppear:\n    // Load initial data if needed\n    return .none\n  }\n}\n*/"
  },
  
  "environment_template": {
    "filename": "{Feature}Environment.swift",
    "code": "import ComposableArchitecture\nimport Foundation\n\n// MARK: - {Feature}Environment\n\n/// Dependencies container for {Feature} feature\n/// MUST inject UseCases (NOT Repositories), include mainQueue scheduler\nstruct {Feature}Environment {\n  // MARK: - UseCases\n  \n  var fetchDataUseCase: FetchDataUseCaseProtocol\n  \n  // MARK: - Services\n  \n  var analyticsService: AnalyticsServiceProtocol\n  var loggerService: LoggerServiceProtocol\n  \n  // MARK: - Schedulers\n  \n  var mainQueue: AnySchedulerOf<DispatchQueue>\n  \n  // MARK: - Navigation Callbacks (Optional)\n  \n  var onComplete: (() -> Void)?\n  \n  // MARK: - Testing Support\n  \n  /// Mock environment for testing\n  static var mock: Self {\n    Self(\n      fetchDataUseCase: MockFetchDataUseCase(),\n      analyticsService: MockAnalyticsService(),\n      loggerService: MockLoggerService(),\n      mainQueue: .immediate,\n      onComplete: nil\n    )\n  }\n  \n  /// Live environment for production\n  static var live: Self {\n    Self(\n      fetchDataUseCase: Resolver.resolve(),\n      analyticsService: Resolver.resolve(),\n      loggerService: Resolver.resolve(),\n      mainQueue: .main,\n      onComplete: nil\n    )\n  }\n}\n\n// MARK: - Example with Navigation Callbacks\n\n/*\nstruct LoginEnvironment {\n  // UseCases\n  var loginUseCase: LoginUserUseCaseProtocol\n  \n  // Services\n  var analyticsService: AnalyticsServiceProtocol\n  var validationService: ValidationServiceProtocol\n  \n  // Schedulers\n  var mainQueue: AnySchedulerOf<DispatchQueue>\n  \n  // Navigation\n  var onLoginSuccess: ((User) -> Void)?\n  var onRegisterTapped: (() -> Void)?\n  \n  static var mock: Self {\n    Self(\n      loginUseCase: MockLoginUseCase(),\n      analyticsService: MockAnalyticsService(),\n      validationService: MockValidationService(),\n      mainQueue: .immediate,\n      onLoginSuccess: nil,\n      onRegisterTapped: nil\n    )\n  }\n}\n*/"
  },
  
  "view_template": {
    "filename": "{Feature}View.swift",
    "code": "import ComposableArchitecture\nimport SwiftUI\n\n// MARK: - {Feature}View\n\n/// View for {Feature} feature\n/// CRITICAL: Animation state in @State, Business state in Store\nstruct {Feature}View: View {\n  // MARK: - Properties\n  \n  let store: Store<{Feature}State, {Feature}Action>\n  \n  // MARK: - Animation State (View-local)\n  // ✅ CORRECT: Animation values in @State\n  \n  @State private var buttonScale: CGFloat = 1.0\n  @State private var isAnimating: Bool = false\n  \n  // MARK: - Body\n  \n  var body: some View {\n    WithViewStore(store) { viewStore in\n      VStack(spacing: 24) {\n        // Content here\n        \n        Button(\"Action\") {\n          viewStore.send(.actionButtonTapped)\n        }\n        .scaleEffect(buttonScale)\n        .disabled(viewStore.isLoading)\n        \n        if viewStore.isLoading {\n          ProgressView()\n        }\n        \n        if let error = viewStore.errorMessage {\n          Text(error)\n            .foregroundColor(.red)\n            .font(.caption)\n        }\n      }\n      .padding()\n      // ✅ CORRECT: Business state change → animation trigger\n      .onChange(of: viewStore.status) { status in\n        handleStatusChange(status)\n      }\n    }\n  }\n  \n  // MARK: - Private Methods\n  \n  /// Handle status changes with animations\n  private func handleStatusChange(_ status: {Feature}State.Status) {\n    switch status {\n    case .loading:\n      withAnimation(.easeInOut(duration: 0.15)) {\n        buttonScale = 0.95\n      }\n      \n    case .loaded:\n      withAnimation(.spring(response: 0.3)) {\n        buttonScale = 1.0\n      }\n      \n    case .error:\n      buttonScale = 1.0\n      // Trigger shake animation\n      withAnimation(.default) {\n        isAnimating = true\n      }\n      DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {\n        isAnimating = false\n      }\n      \n    case .idle:\n      buttonScale = 1.0\n    }\n  }\n}\n\n// MARK: - Preview\n\n#if DEBUG\nstruct {Feature}View_Previews: PreviewProvider {\n  static var previews: some View {\n    {Feature}View(\n      store: Store(\n        initialState: {Feature}State(),\n        reducer: {feature}Reducer,\n        environment: .mock\n      )\n    )\n  }\n}\n#endif\n\n// MARK: - Example with Complete View\n\n/*\nstruct LoginView: View {\n  let store: Store<LoginState, LoginAction>\n  \n  // ✅ Animation state in @State\n  @State private var buttonScale: CGFloat = 1.0\n  @State private var isShaking: Bool = false\n  @State private var showPassword: Bool = false\n  \n  var body: some View {\n    WithViewStore(store) { viewStore in\n      VStack(spacing: 24) {\n        // Email field\n        TextField(\"Email\", text: viewStore.binding(\n          get: \\.email,\n          send: LoginAction.emailChanged\n        ))\n        .textFieldStyle(.roundedBorder)\n        .autocapitalization(.none)\n        .keyboardType(.emailAddress)\n        \n        // Password field\n        HStack {\n          if showPassword {\n            TextField(\"Password\", text: viewStore.binding(\n              get: \\.password,\n              send: LoginAction.passwordChanged\n            ))\n          } else {\n            SecureField(\"Password\", text: viewStore.binding(\n              get: \\.password,\n              send: LoginAction.passwordChanged\n            ))\n          }\n          \n          Button(action: { showPassword.toggle() }) {\n            Image(systemName: showPassword ? \"eye.slash\" : \"eye\")\n              .foregroundColor(.secondary)\n          }\n        }\n        .textFieldStyle(.roundedBorder)\n        \n        // Login button\n        Button(\"Login\") {\n          viewStore.send(.loginButtonTapped)\n        }\n        .buttonStyle(.borderedProminent)\n        .scaleEffect(buttonScale)\n        .disabled(viewStore.isLoading || !viewStore.isFormValid)\n        .modifier(ShakeEffect(shakes: isShaking ? 3 : 0))\n        \n        if viewStore.isLoading {\n          ProgressView()\n        }\n        \n        if let error = viewStore.errorMessage {\n          Text(error)\n            .foregroundColor(.red)\n            .font(.caption)\n        }\n        \n        // Register link\n        Button(\"Don't have an account? Sign up\") {\n          viewStore.send(.registerButtonTapped)\n        }\n        .font(.footnote)\n      }\n      .padding()\n      .onChange(of: viewStore.status) { status in\n        handleStatusChange(status)\n      }\n    }\n  }\n  \n  private func handleStatusChange(_ status: LoginState.Status) {\n    switch status {\n    case .loading:\n      withAnimation(.easeInOut(duration: 0.15)) {\n        buttonScale = 0.95\n      }\n      \n    case .success:\n      withAnimation(.spring(response: 0.3)) {\n        buttonScale = 1.1\n      }\n      DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {\n        withAnimation(.default) {\n          buttonScale = 1.0\n        }\n      }\n      \n    case .error:\n      buttonScale = 1.0\n      withAnimation(.default) {\n        isShaking = true\n      }\n      DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {\n        isShaking = false\n      }\n      \n    case .idle:\n      buttonScale = 1.0\n    }\n  }\n}\n\n// Shake animation modifier\nstruct ShakeEffect: GeometryEffect {\n  var shakes: Int\n  \n  var animatableData: CGFloat {\n    get { CGFloat(shakes) }\n    set { shakes = Int(newValue) }\n  }\n  \n  func effectValue(size: CGSize) -> ProjectionTransform {\n    let offset = sin(animatableData * .pi * 2) * 10\n    return ProjectionTransform(\n      CGAffineTransform(translationX: offset, y: 0)\n    )\n  }\n}\n*/"
  },
  
  "integration_example": {
    "description": "How to integrate TCA screen in Coordinator or App",
    "coordinator_usage": "class AuthCoordinator {\n  func showLogin() {\n    let environment = LoginEnvironment(\n      loginUseCase: Resolver.resolve(),\n      analyticsService: Resolver.resolve(),\n      validationService: Resolver.resolve(),\n      mainQueue: .main,\n      onLoginSuccess: { [weak self] user in\n        self?.showHome(user: user)\n      },\n      onRegisterTapped: { [weak self] in\n        self?.showRegister()\n      }\n    )\n    \n    let store = Store(\n      initialState: LoginState(),\n      reducer: loginReducer,\n      environment: environment\n    )\n    \n    let loginView = LoginView(store: store)\n    let hostingController = UIHostingController(rootView: loginView)\n    \n    navigationController.pushViewController(\n      hostingController,\n      animated: true\n    )\n  }\n}",
    "swiftui_app_usage": "@main\nstruct MyApp: App {\n  var body: some Scene {\n    WindowGroup {\n      LoginView(\n        store: Store(\n          initialState: LoginState(),\n          reducer: loginReducer,\n          environment: .live\n        )\n      )\n    }\n  }\n}"
  },
  
  "checklist": {
    "before_generating": [
      "✓ Define business state in State struct (NO animation values)",
      "✓ List ALL actions in Action enum (user + system)",
      "✓ Write pure Reducer with exhaustive switch",
      "✓ Create Environment with UseCases + schedulers",
      "✓ Build View with @State for animations"
    ],
    "validation": [
      "✓ State is struct conforming to Equatable",
      "✓ NO CGFloat/Double/Angle in State (animation values)",
      "✓ Action enum is exhaustive",
      "✓ Reducer handles ALL cases",
      "✓ Reducer returns Effect or .none",
      "✓ Environment has .mock and .live",
      "✓ View uses @State for animations",
      "✓ View uses .onChange(of: viewStore.state) for triggers"
    ]
  }
}
