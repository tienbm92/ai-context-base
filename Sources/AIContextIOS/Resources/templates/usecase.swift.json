{
  "template_type": "usecase",
  "description": "Domain layer UseCase with protocol and implementation",
  
  "protocol_template": "import Foundation\n\n/// Protocol defining the {{ACTION}}{{ENTITY}} use case\nprotocol {{ACTION}}{{ENTITY}}UseCaseProtocol {\n    /// Executes the {{ACTION}} operation\n    /// - Parameters:\n    ///   - param1: Description of param1\n    /// - Returns: {{ENTITY}} on success\n    /// - Throws: ValidationError or RepositoryError\n    func execute(param1: String) async throws -> {{ENTITY}}\n}",
  
  "implementation_template": "import Foundation\n\n/// Use case for {{ACTION}}ing {{ENTITY}}\nclass {{ACTION}}{{ENTITY}}UseCase: {{ACTION}}{{ENTITY}}UseCaseProtocol {\n    // MARK: - Dependencies\n    private let repository: {{ENTITY}}RepositoryProtocol\n    private let validator: ValidationService\n    \n    // MARK: - Init\n    init(\n        repository: {{ENTITY}}RepositoryProtocol,\n        validator: ValidationService = ValidationService()\n    ) {\n        self.repository = repository\n        self.validator = validator\n    }\n    \n    // MARK: - Execute\n    func execute(param1: String) async throws -> {{ENTITY}} {\n        // 1. Validate input (Business Rules)\n        guard !param1.isEmpty else {\n            throw ValidationError.emptyField(\"param1\")\n        }\n        \n        // 2. Call repository\n        let result = try await repository.{{ACTION_LOWER}}(param1: param1)\n        \n        // 3. Return domain entity\n        return result\n    }\n}\n\n// MARK: - Validation Error\nenum ValidationError: Error, LocalizedError {\n    case emptyField(String)\n    case invalidFormat(String)\n    \n    var errorDescription: String? {\n        switch self {\n        case .emptyField(let field):\n            return \"\\(field) cannot be empty\"\n        case .invalidFormat(let field):\n            return \"\\(field) has invalid format\"\n        }\n    }\n}"
}
