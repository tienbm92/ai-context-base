{
  "$schema": "https://json-schema.org/draft-07/schema",
  "id": "ios.animation_guidelines.v2",
  "version": "2.0.0",
  "last_updated": "2025-01-20",
  
  "_critical_warning": "AI MUST follow these rules to prevent 60fps jank and state management bugs",
  
  "core_principle": {
    "rule": "Animation state lives in @State (View layer), NEVER in ViewModel @Published properties",
    "rationale": [
      "Performance: ViewModel @Published updates trigger full view re-render, animations need 60fps updates",
      "Separation: Animations are UI concerns, not business logic",
      "Testability: ViewModel tests remain independent of animation details",
      "Framework design: SwiftUI optimized for @State animations, ViewModel optimized for business state"
    ],
    "summary": "Business state in ViewModel @Published → triggers → @State animation in View"
  },
  
  "correct_pattern": {
    "viewmodel": "class MyViewModel: ObservableObject {\n  @Published var status: Status = .idle  // Business state only\n  enum Status { case idle, loading, success, error }\n}",
    "view": "struct MyView: View {\n  @StateObject private var viewModel: MyViewModel\n  @State private var buttonScale: CGFloat = 1.0  // Animation state\n  \n  var body: some View {\n    Button(\"Submit\")\n      .scaleEffect(buttonScale)\n      .onChange(of: viewModel.status) { status in\n        if status == .loading {\n          withAnimation { buttonScale = 0.95 }\n        } else {\n          buttonScale = 1.0\n        }\n      }\n  }\n}"
  },
  
  "forbidden_pattern": {
    "description": "DO NOT put animation values in ViewModel",
    "wrong_viewmodel": "// ❌ FORBIDDEN\nclass MyViewModel: ObservableObject {\n  @Published var buttonScale: CGFloat = 1.0  // NO!\n  @Published var pulseOpacity: Double = 1.0  // NO!\n}",
    "why_wrong": "Causes 60fps jank - @Published updates are expensive, animations need high frequency"
  },
  
  "animation_patterns": {
    "pulse_on_loading": {
      "viewmodel": "@Published var isLoading: Bool = false",
      "view": "@State private var pulseScale: CGFloat = 1.0\n\n.onChange(of: viewModel.isLoading) { isLoading in\n  if isLoading {\n    withAnimation(.easeInOut.repeatForever()) {\n      pulseScale = 1.2\n    }\n  } else {\n    pulseScale = 1.0\n  }\n}"
    },
    "shake_on_error": {
      "viewmodel": "@Published var errorMessage: String?",
      "view": "@State private var shakeCount: Int = 0\n\n.onChange(of: viewModel.errorMessage) { error in\n  if error != nil {\n    withAnimation { shakeCount += 1 }\n  }\n}"
    },
    "button_press": {
      "viewmodel": "@Published var status: Status = .idle",
      "view": "@State private var buttonScale: CGFloat = 1.0\n\n.onChange(of: viewModel.status) { status in\n  switch status {\n  case .loading:\n    withAnimation { buttonScale = 0.95 }\n  case .success:\n    withAnimation(.spring()) { buttonScale = 1.1 }\n  default:\n    buttonScale = 1.0\n  }\n}"
    }
  },
  
  "property_wrappers": {
    "@State": "For animation values and transient UI state",
    "@FocusState": "For TextField focus state",
    "@GestureState": "For gesture-driven animations",
    "@Published": "For business state in ViewModel (NOT animations)"
  },
  
  "validation_checklist": [
    "Animation values declared with @State in View",
    "Business state triggers via onChange(of: viewModel.property)",
    "withAnimation wraps @State updates",
    "NO animation values in ViewModel @Published",
    "Transient UI state uses @State/@FocusState/@GestureState"
  ],
  
  "common_mistakes": [
    {
      "mistake": "Putting buttonScale in ViewModel @Published",
      "fix": "Use @State in View, trigger via onChange(of: viewModel.status)"
    },
    {
      "mistake": "Using .animation() modifier without withAnimation",
      "fix": "Use explicit withAnimation for predictable animations"
    }
  ],
  
  "exceptions": {
    "when_animation_timing_is_business_logic": {
      "description": "Only when animation duration/value affects business rules",
      "examples": ["OTP countdown (timeout affects validation)", "Auction timer (end time triggers bid close)"],
      "pattern": "Timer/countdown value in ViewModel @Published, visual pulse/color in @State"
    }
  }
}
