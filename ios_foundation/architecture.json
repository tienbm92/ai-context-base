{
  "$schema": "https://json-schema.org/draft-07/schema",
  "id": "ios.architecture.mvvm.v3",
  "version": "3.0.0",
  "last_updated": "2025-11-01",
  
  "architecture_pattern": "Clean Architecture with MVVM",
  "presentation_pattern": "MVVM - Model/View/ViewModel (ObservableObject + @Published)",
  
  "principles": {
    "separation_of_concerns": "Each layer has single responsibility with clear boundaries",
    "dependency_rule": "Dependencies point inward: Presentation → Domain ← Data",
    "testability": "ViewModel logic testable with mocks, protocol-based dependencies",
    "scalability": "Feature modules organized by domain, ViewModels per screen",
    "ai_friendly": "Observable state (@Published), explicit methods, predictable patterns",
    "no_external_dependencies": "Pure Swift/Combine/SwiftUI - no third-party state management libraries"
  },
  
  "layers": {
    "presentation": {
      "description": "UI layer with SwiftUI Views and MVVM (ViewModel manages business state)",
      "responsibilities": [
        "Display data to user via SwiftUI Views",
        "Handle user interactions via ViewModel methods",
        "Manage business state via @Published properties in ViewModel",
        "Trigger side effects via async/await or Combine in ViewModel",
        "Manage UI animations via @State (NOT in ViewModel)"
      ],
      "mvvm_components": {
        "viewmodel": {
          "type": "class ObservableObject",
          "description": "Manages business state and handles user actions",
          "rules": [
            "MUST be class conforming to ObservableObject",
            "MUST use @Published for business state properties",
            "MUST contain business state ONLY (no animation values)",
            "MUST inject UseCases via init (NOT Repositories)",
            "MUST provide public methods for user actions",
            "FORBIDDEN: CGFloat/Double for animations, transient UI state"
          ],
          "naming": "{Feature}ViewModel",
          "example": "final class LoginViewModel: ObservableObject {\n  // Business state\n  @Published private(set) var email: String = \"\"\n  @Published private(set) var password: String = \"\"\n  @Published private(set) var status: Status = .idle\n  @Published private(set) var errorMessage: String?\n  \n  enum Status: Equatable {\n    case idle\n    case loading\n    case success(User)\n    case error\n  }\n  \n  // Dependencies\n  private let loginUseCase: LoginUserUseCaseProtocol\n  private var cancellables = Set<AnyCancellable>()\n  \n  init(loginUseCase: LoginUserUseCaseProtocol) {\n    self.loginUseCase = loginUseCase\n  }\n  \n  // User actions\n  func emailChanged(_ newEmail: String) {\n    email = newEmail\n  }\n  \n  func loginButtonTapped() {\n    status = .loading\n    Task {\n      do {\n        let user = try await loginUseCase.execute(email: email, password: password)\n        await MainActor.run { status = .success(user) }\n      } catch {\n        await MainActor.run { \n          status = .error\n          errorMessage = error.localizedDescription\n        }\n      }\n    }\n  }\n  \n  // Computed properties\n  var isLoading: Bool {\n    if case .loading = status { return true }\n    return false\n  }\n}"
        },
        
        "view": {
          "framework": "SwiftUI",
          "pattern": "@StateObject or @ObservedObject for ViewModel",
          "animation_critical": "Use @State for animations, NOT ViewModel @Published",
          "rules": [
            "MUST use @StateObject (owner) or @ObservedObject (passed in) for ViewModel",
            "MUST use @State for UI/animation state (separate from ViewModel)",
            "MUST call ViewModel methods for user actions",
            "MUST observe ViewModel @Published properties directly",
            "SHOULD extract subviews for complex UIs"
          ],
          "example": "struct LoginView: View {\n  @StateObject var viewModel: LoginViewModel\n  \n  // ✅ CORRECT: Animation state in @State\n  @State private var isShaking = false\n  @State private var buttonScale: CGFloat = 1.0\n  \n  var body: some View {\n    VStack(spacing: 24) {\n      TextField(\"Email\", text: .init(\n        get: { viewModel.email },\n        set: { viewModel.emailChanged($0) }\n      ))\n      \n      SecureField(\"Password\", text: .init(\n        get: { viewModel.password },\n        set: { viewModel.passwordChanged($0) }\n      ))\n      \n      Button(\"Login\") {\n        viewModel.loginButtonTapped()\n      }\n      .scaleEffect(buttonScale)\n      .disabled(viewModel.isLoading)\n      .modifier(ShakeEffect(shakes: isShaking ? 3 : 0))\n    }\n    // ✅ Business state change → trigger UI animation\n    .onChange(of: viewModel.status) { status in\n      switch status {\n      case .loading:\n        withAnimation(.easeInOut(duration: 0.15)) {\n          buttonScale = 0.95\n        }\n        \n      case .error:\n        buttonScale = 1.0\n        withAnimation(.default) {\n          isShaking = true\n        }\n        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {\n          isShaking = false\n        }\n        \n      case .success:\n        buttonScale = 1.0\n        \n      case .idle:\n        buttonScale = 1.0\n      }\n    }\n  }\n}"
        }
      },
      "file_structure": "Features/{Feature}/Presentation/\n├── {Feature}ViewModel.swift   # ViewModel (ObservableObject)\n├── {Feature}View.swift         # SwiftUI View\n└── Components/\n    └── {Component}View.swift   # Reusable subviews"
    },
    
    "domain": {
      "description": "Pure Swift business logic layer - NO framework dependencies",
      "responsibilities": [
        "Define business entities (models)",
        "Define business rules (use cases)",
        "Define repository contracts (protocols)",
        "Contain NO implementation details"
      ],
      "components": {
        "entities": {
          "description": "Business models representing core domain concepts",
          "rules": [
            "MUST be pure Swift structs/classes",
            "MUST conform to Codable for serialization (if needed)",
            "MUST conform to Equatable/Hashable (if needed for collections)",
            "MUST NOT import UIKit/SwiftUI/Combine/third-party frameworks",
            "SHOULD be immutable (struct preferred over class)",
            "SHOULD have meaningful names reflecting business domain"
          ],
          "naming_convention": "{Entity} (e.g., User, SmartTask, Portfolio)",
          "example": "struct User: Codable, Equatable {\n  let id: String\n  let email: String\n  let name: String\n  let createdAt: Date\n  let portfolios: [Portfolio]\n  \n  // Business logic methods allowed\n  func totalPortfolioValue() -> Decimal {\n    portfolios.reduce(0) { $0 + $1.totalValue }\n  }\n}"
        },
        "usecases": {
          "description": "Application-specific business rules (interactors)",
          "pattern": "Single Responsibility - one use case does ONE thing",
          "rules": [
            "MUST have protocol + implementation separation",
            "MUST use async/await for async operations",
            "MUST throw errors or return Result<T, Error>",
            "MUST NOT contain UI logic or presentation concerns",
            "MUST call Repository protocols (NOT implementations)",
            "ONE use case = ONE business action"
          ],
          "naming_convention": "{Action}{Entity}UseCase (e.g., LoginUserUseCase, FetchPortfolioUseCase)",
          "example": "protocol LoginUserUseCaseProtocol {\n  func execute(email: String, password: String) async throws -> User\n}\n\nclass LoginUserUseCase: LoginUserUseCaseProtocol {\n  private let authRepository: AuthRepositoryProtocol\n  \n  init(authRepository: AuthRepositoryProtocol) {\n    self.authRepository = authRepository\n  }\n  \n  func execute(email: String, password: String) async throws -> User {\n    guard !email.isEmpty, !password.isEmpty else {\n      throw ValidationError.emptyFields\n    }\n    return try await authRepository.login(email: email, password: password)\n  }\n}"
        },
        "repositories": {
          "type": "Protocol (abstract interface)",
          "description": "Define data access contracts without implementation",
          "rules": [
            "MUST be protocol in domain layer (interface only)",
            "MUST use Domain entities (NOT DTOs)",
            "MUST define async methods with throws",
            "MUST NOT contain implementation logic",
            "Implementation lives in Data layer"
          ],
          "naming_convention": "{Entity}RepositoryProtocol",
          "example": "protocol AuthRepositoryProtocol {\n  func login(email: String, password: String) async throws -> User\n  func logout() async throws\n  func getCurrentUser() async throws -> User?\n}"
        }
      },
      "file_structure": "Features/{Feature}/Domain/\n├── Entities/\n│   └── {Entity}.swift\n├── UseCases/\n│   ├── {Action}{Entity}UseCaseProtocol.swift\n│   └── {Action}{Entity}UseCase.swift\n└── Repositories/\n    └── {Entity}RepositoryProtocol.swift"
    },
    
    "data": {
      "description": "External data sources - API, Database, Cache implementations",
      "responsibilities": [
        "Implement repository protocols from Domain layer",
        "Fetch data from remote/local sources",
        "Map DTOs to Domain entities",
        "Handle caching strategies",
        "Manage data persistence"
      ],
      "components": {
        "repositories": {
          "description": "Concrete implementations of Domain repository protocols",
          "rules": [
            "MUST implement Domain layer repository protocol",
            "MUST inject DataSources via DI",
            "MUST map DTOs to Domain entities",
            "MUST handle errors from data sources",
            "SHOULD implement caching logic if needed"
          ],
          "naming_convention": "{Entity}Repository (implementation, no 'Impl' suffix)",
          "example": "class AuthRepository: AuthRepositoryProtocol {\n  private let remoteDataSource: AuthRemoteDataSource\n  private let localDataSource: AuthLocalDataSource\n  \n  init(remote: AuthRemoteDataSource, local: AuthLocalDataSource) {\n    self.remoteDataSource = remote\n    self.localDataSource = local\n  }\n  \n  func login(email: String, password: String) async throws -> User {\n    let dto = try await remoteDataSource.login(email: email, password: password)\n    let user = dto.user.toDomain()\n    try await localDataSource.saveUser(user)\n    return user\n  }\n}"
        },
        "datasources": {
          "types": ["Remote (API)", "Local (Database/Cache)"],
          "rules": [
            "MUST work with DTOs (Data Transfer Objects)",
            "MUST NOT know about Domain entities",
            "Remote: Use APIClient service (URLSession)",
            "Local: Use storage solutions (Realm, Keychain, UserDefaults)"
          ]
        },
        "models": {
          "description": "DTOs (Data Transfer Objects) for API/database communication",
          "rules": [
            "MUST conform to Codable",
            "MUST have toDomain() mapper method",
            "CodingKeys MUST match API response keys (snake_case → camelCase)",
            "MUST NOT be used outside Data layer"
          ],
          "naming_convention": "{Entity}DTO"
        }
      },
      "file_structure": "Features/{Feature}/Data/\n├── Models/\n│   └── {Entity}DTO.swift\n├── DataSources/\n│   ├── Remote/\n│   │   └── {Feature}RemoteDataSource.swift\n│   └── Local/\n│       └── {Feature}LocalDataSource.swift\n└── Repositories/\n    └── {Entity}Repository.swift"
    }
  },
  
  "dependency_flow": {
    "rule": "Dependency Inversion Principle",
    "diagram": "Presentation (MVVM) → Domain ← Data",
    "explanation": [
      "Presentation depends on Domain (ViewModels call UseCases)",
      "Data depends on Domain (Repositories implement Domain protocols)",
      "Domain has ZERO dependencies (pure Swift)",
      "ViewModels inject UseCases via init"
    ],
    "example": "// Presentation → Domain\nfinal class LoginViewModel: ObservableObject {\n  private let loginUseCase: LoginUseCaseProtocol  // Domain protocol injected\n  \n  init(loginUseCase: LoginUseCaseProtocol) {\n    self.loginUseCase = loginUseCase\n  }\n}\n\n// Data → Domain\nclass AuthRepository: AuthRepositoryProtocol {  // Implements Domain protocol\n  // Implementation details\n}"
  },
  
  "feature_modules": {
    "organization": "Group by feature domain, not technical layer",
    "rationale": "Features are cohesive units that change together",
    "structure": "Features/\n├── Authentication/\n│   ├── Domain/\n│   │   ├── Entities/User.swift\n│   │   ├── UseCases/\n│   │   │   ├── LoginUserUseCaseProtocol.swift\n│   │   │   └── LoginUserUseCase.swift\n│   │   └── Repositories/AuthRepositoryProtocol.swift\n│   ├── Data/\n│   │   ├── Models/UserDTO.swift\n│   │   ├── DataSources/\n│   │   │   ├── AuthRemoteDataSource.swift\n│   │   │   └── AuthLocalDataSource.swift\n│   │   └── Repositories/AuthRepository.swift\n│   └── Presentation/\n│       ├── Login/\n│       │   ├── LoginViewModel.swift\n│       │   └── LoginView.swift\n│       └── Register/\n│           ├── RegisterViewModel.swift\n│           └── RegisterView.swift\n└── Portfolio/\n    ├── Domain/\n    ├── Data/\n    └── Presentation/\n        ├── Dashboard/\n        │   ├── DashboardViewModel.swift\n        │   └── DashboardView.swift\n        └── Components/\n            └── PortfolioCardView.swift",
    "_comment_structure": "Each feature screen has 2 files: ViewModel + View (vs 5 TCA files)"
  },
  
  "cross_cutting_concerns": {
    "core_services": {
      "location": "Core/Services/",
      "examples": [
        "APIClient (networking)",
        "Logger (logging)",
        "Analytics (tracking)",
        "SecurityService (encryption, keychain)"
      ],
      "injection": "Via DI container (Resolver), available to all features"
    },
    "extensions": {
      "location": "Core/Extensions/",
      "examples": ["Foundation+Extensions.swift", "SwiftUI+Extensions.swift"]
    },
    "utilities": {
      "location": "Core/Utilities/",
      "examples": ["DateFormatter+App.swift", "Validator.swift"]
    }
  },
  
  "ai_generation_rules": {
    "_comment_purpose": "Step-by-step guide for AI to generate MVVM features correctly",
    "when_creating_feature": {
      "order": [
        "1. Start with Domain: Define Entity structs (pure Swift, Codable, Equatable)",
        "2. Define Repository Protocol in Domain (async methods, throws errors)",
        "3. Create UseCases with protocol + implementation (business logic, validation)",
        "4. Move to Data: Create DTOs with CodingKeys + toDomain() mapper",
        "5. Implement DataSources (Remote for API, Local for cache/database)",
        "6. Implement Repository (combine Remote + Local, handle caching)",
        "7. Move to Presentation: Create ViewModel (ObservableObject, @Published state)",
        "8. Create View (SwiftUI, @StateObject for ViewModel, @State for animations)",
        "9. Register dependencies in DI container (Resolver)"
      ]
    },
    "mvvm_specific_rules": {
      "viewmodel_rules": [
        "MUST be class conforming to ObservableObject",
        "MUST use @Published for business state (observable by View)",
        "MUST contain business state ONLY (no UI/animation transient state)",
        "FORBIDDEN: CGFloat/Double animation values, @State-like transient properties",
        "MUST inject UseCases via init (NOT Repositories)",
        "MUST provide public methods for user actions",
        "USE async/await or Combine for side effects"
      ],
      "view_rules": [
        "MUST use @StateObject (owner) or @ObservedObject (passed) for ViewModel",
        "MUST use @State for UI animations (NOT ViewModel @Published)",
        "CALL ViewModel methods for user actions",
        "OBSERVE ViewModel @Published properties directly",
        "USE .onChange(of: viewModel.property) to trigger animations"
      ],
      "animation_rules": [
        "✅ DO: @State private var buttonScale = 1.0 in View",
        "✅ DO: .onChange(of: viewModel.status) { _ in withAnimation { buttonScale = 0.95 } }",
        "❌ DON'T: @Published var animationOffset in ViewModel",
        "❌ DON'T: Put transient UI state in ViewModel",
        "RATIONALE: ViewModel updates trigger full View re-render, animations need 60fps"
      ]
    },
    "validation_checklist": [
      "✓ Domain layer has NO imports (except Foundation)",
      "✓ ViewModels call UseCases via injected dependencies, NOT Repositories",
      "✓ DTOs have toDomain() methods with proper mapping",
      "✓ Repository protocols in Domain, implementations in Data",
      "✓ Views have NO business logic (only presentation/formatting)",
      "✓ ViewModel is ObservableObject with @Published business state",
      "✓ Animation state in @State (View), business state in ViewModel @Published",
      "✓ All dependencies injected via ViewModel init",
      "✓ Unit tests for ViewModels (business logic)",
      "✓ NO animation values (CGFloat/Double/Angle) in ViewModel"
    ],
    "common_mistakes_to_avoid": [
      "❌ Putting animation state in ViewModel @Published (causes 60fps jank)",
      "❌ Calling Repositories directly from ViewModel (violates Clean Architecture)",
      "❌ Performing side effects synchronously in ViewModel (use Task/async-await)",
      "❌ Forgetting @MainActor.run when updating @Published from async context",
      "❌ Not injecting dependencies via init",
      "❌ Importing UIKit/SwiftUI in Domain layer",
      "❌ Skipping toDomain() mapper in DTOs"
    ]
  }
}
