{
  "$schema": "https://json-schema.org/draft-07/schema",
  "id": "ios.state_management.v3",
  "version": "3.0.0",
  "last_updated": "2025-11-01",
  
  "primary_framework": "MVVM with Combine + async/await",
  "async_pattern": "async/await with Combine for reactive state",
  "_comment": "Migrated to MVVM - ViewModel replaces Store/State/Action/Reducer",
  
  "state_ownership": {
    "business_state": {
      "location": "ViewModel (@Published properties)",
      "mechanism": "ObservableObject with @Published properties",
      "examples": ["@Published var loginStatus: LoginStatus = .idle", "@Published var userData: User?", "@Published var errorMessage: String?", "@Published var isLoading: Bool = false"],
      "triggers_view_updates": true,
      "pattern": "class LoginViewModel: ObservableObject {\n  @Published var email: String = \"\"\n  @Published var password: String = \"\"\n  @Published var status: Status = .idle\n}"
    },
    "viewstate_pattern": {
      "location": "ViewModel (@Published ViewState struct)",
      "description": "OPTIONAL: Single ViewState struct containing all View-ready data",
      "when_to_use": [
        "View has complex formatting/mapping logic",
        "Multiple @Published properties updated together",
        "Want to optimize SwiftUI updates with Equatable"
      ],
      "mechanism": "ViewState struct (Equatable) exposes pre-formatted data",
      "examples": ["@Published private(set) var viewState: ViewState"],
      "benefits": [
        "View becomes simple renderer",
        "Single source of truth for rendering",
        "Better performance (Equatable reduces updates)",
        "Easier testing (test ViewState mapping)"
      ],
      "pattern": "class LoginViewModel: ObservableObject {\n  @Published private(set) var viewState: ViewState = .idle\n  \n  @Published private var email: String = \"\"\n  @Published private var status: Status = .idle\n  \n  struct ViewState: Equatable {\n    let buttonTitle: String\n    let isButtonEnabled: Bool\n    let showsLoading: Bool\n    let errorMessage: String?\n  }\n  \n  private func updateViewState() {\n    viewState = ViewState(\n      buttonTitle: status == .loading ? \"Signing in...\" : \"Sign In\",\n      isButtonEnabled: !email.isEmpty && status != .loading,\n      showsLoading: status == .loading,\n      errorMessage: nil\n    )\n  }\n}",
      "see_also": "viewstate_pattern.json"
    },
    "ui_animation_state": {
      "location": "View (@State)",
      "mechanism": "@State properties (SwiftUI)",
      "examples": ["animationProgress", "dragOffset", "isExpanded", "rotation", "buttonScale"],
      "triggers_view_updates": true,
      "performance": "Optimized for 60fps, bypasses ViewModel overhead",
      "critical_rule": "NEVER put animation values in ViewModel @Published properties"
    },
    "navigation_state": {
      "location": "ViewModel (@Published intent) or Navigator protocol",
      "description": "Navigation managed via intent-based pattern (default) or Navigator injection (sparingly)",
      "mechanism": "@Published var navigationIntent: NavigationIntent? or Navigator protocol",
      "examples": ["@Published var navigationIntent: NavigationIntent?", "navigator?.push(.home)"],
      "patterns": [
        "Intent-based: ViewModel publishes intent, View executes",
        "Navigator injection: ViewModel calls Navigator protocol",
        "Coordinator: Manages complex multi-screen flows"
      ],
      "see_also": "navigation_patterns.json"
    }
  },
  
  "viewmodel_state": {
    "description": "ObservableObject that holds business state and exposes methods for View actions",
    "creation": "class LoginViewModel: ObservableObject {\n  @Published var email: String = \"\"\n  @Published var password: String = \"\"\n  @Published var status: LoginStatus = .idle\n  \n  private let loginUseCase: LoginUserUseCaseProtocol\n  private var cancellables = Set<AnyCancellable>()\n  \n  init(loginUseCase: LoginUserUseCaseProtocol) {\n    self.loginUseCase = loginUseCase\n  }\n}",
    "observation": "struct LoginView: View {\n  @StateObject private var viewModel: LoginViewModel\n  \n  var body: some View {\n    TextField(\"Email\", text: $viewModel.email)\n    Text(viewModel.status.description)\n  }\n}",
    "state_updates": "Direct property mutation or async method calls",
    "thread_safety": "@Published updates on main thread automatically (ObservableObject conforms to MainActor)",
    "view_integration": "Use @StateObject for ownership, @ObservedObject for passing"
  },
  
  "async_patterns": {
    "description": "Use async/await for asynchronous operations, Combine for reactive streams",
    "async_methods": {
      "when": "One-shot operations (login, fetch data, submit form)",
      "pattern": "func login() async {\n  status = .loading\n  do {\n    let user = try await loginUseCase.execute(\n      email: email,\n      password: password\n    )\n    status = .success(user)\n  } catch {\n    status = .error(error.localizedDescription)\n  }\n}",
      "view_call": "Button(\"Login\") {\n  Task {\n    await viewModel.login()\n  }\n}"
    },
    "combine_publishers": {
      "when": "Reactive streams (search debouncing, form validation, combining inputs)",
      "pattern": "private func setupBindings() {\n  $searchText\n    .debounce(for: 0.3, scheduler: DispatchQueue.main)\n    .removeDuplicates()\n    .sink { [weak self] text in\n      self?.performSearch(text)\n    }\n    .store(in: &cancellables)\n  \n  Publishers.CombineLatest($email, $password)\n    .map { email, password in\n      !email.isEmpty && email.contains(\"@\") && !password.isEmpty\n    }\n    .assign(to: &$isFormValid)\n}",
      "cleanup": "private var cancellables = Set<AnyCancellable>()\n\ndeinit {\n  cancellables.removeAll()\n}"
    },
    "main_actor": {
      "when": "Updating @Published from async context",
      "pattern": "Task {\n  let result = try await useCase.execute()\n  await MainActor.run {\n    self.status = .success(result)\n  }\n}",
      "auto_main_actor": "ObservableObject methods run on MainActor by default when called from View"
    }
  },
  
  "property_wrappers": {
    "_comment": "SwiftUI property wrappers for MVVM",
    "@Published": {
      "usage": "ViewModel business state that triggers View updates",
      "scope": "ViewModel class properties",
      "context": "Use for state that View observes",
      "example": "@Published var isLoading: Bool = false\n@Published var errorMessage: String?"
    },
    "@StateObject": {
      "usage": "View owns ViewModel (creates and manages lifecycle)",
      "example": "@StateObject private var viewModel = LoginViewModel()"
    },
    "@ObservedObject": {
      "usage": "View receives ViewModel (passed from parent)",
      "example": "@ObservedObject var viewModel: LoginViewModel"
    },
    "@State": {
      "usage": "View-local UI and animation state (NOT ViewModel state)",
      "scope": "Private to View",
      "context": "Use for animations triggered by ViewModel state changes",
      "example": "@State private var buttonScale: CGFloat = 1.0\n\n.onChange(of: viewModel.status) { status in\n  withAnimation { buttonScale = 1.2 }\n}"
    },
    "@FocusState": {
      "usage": "TextField focus state",
      "example": "@FocusState private var isEmailFocused: Bool"
    },
    "@GestureState": {
      "usage": "Gesture-driven animations (drag, pinch)",
      "example": "@GestureState private var dragOffset: CGSize = .zero"
    }
  },
  
  "state_patterns": {
    "enum_state_machine": {
      "description": "Explicit state transitions with enum (preferred pattern)",
      "benefits": ["No invalid states", "Exhaustive switch", "Clear transitions"],
      "example": "class LoginViewModel: ObservableObject {\n  @Published var email: String = \"\"\n  @Published var password: String = \"\"\n  @Published var status: Status = .idle\n  \n  enum Status: Equatable {\n    case idle\n    case loading\n    case success(User)\n    case error(String)\n  }\n  \n  func login() async {\n    status = .loading\n    do {\n      let user = try await loginUseCase.execute(email: email, password: password)\n      status = .success(user)\n    } catch {\n      status = .error(error.localizedDescription)\n    }\n  }\n}"
    },
    "computed_properties": {
      "description": "Derive state from @Published properties",
      "example": "class LoginViewModel: ObservableObject {\n  @Published var email: String = \"\"\n  @Published var password: String = \"\"\n  @Published var status: Status = .idle\n  \n  var isLoading: Bool {\n    if case .loading = status { return true }\n    return false\n  }\n  \n  var isFormValid: Bool {\n    !email.isEmpty && email.contains(\"@\") && !password.isEmpty\n  }\n}"
    }
  },
  
  "threading_rules": {
    "viewmodel_threading": {
      "description": "ViewModel methods run on MainActor by default when called from View",
      "state_updates": "@Published property changes automatically trigger View updates on main thread",
      "async_methods": "Can run on background, but must update @Published on MainActor"
    },
    "main_actor_pattern": {
      "description": "Ensure @Published updates happen on main thread in async contexts",
      "pattern": "Task {\n  // Background work\n  let data = try await apiClient.fetch()\n  \n  // Update @Published on main thread\n  await MainActor.run {\n    self.items = data\n    self.isLoading = false\n  }\n}",
      "auto_context": "If ViewModel method is @MainActor, no need for MainActor.run"
    },
    "view_updates": {
      "description": "@Published changes automatically update View on main thread",
      "no_dispatc h_main_needed": "ObservableObject handles thread safety for View updates"
    }
  },
  
  "animation_state_management": {
    "critical_rule": "Animation state MUST be in @State (View), NEVER in ViewModel @Published",
    "correct_pattern": {
      "viewmodel_state": "class TaskViewModel: ObservableObject {\n  @Published var status: Status = .idle  // Business state\n  enum Status { case idle, active, paused }\n}",
      "view_state": "@State private var pulseScale: CGFloat = 1.0  // Animation state",
      "trigger": ".onChange(of: viewModel.status) { status in\n  if status == .active {\n    withAnimation(.easeInOut.repeatForever()) {\n      pulseScale = 1.2\n    }\n  }\n}"
    },
    "why_separate": [
      "Performance: ViewModel @Published updates are expensive, animations need 60fps",
      "Architecture: Animations are UI concerns, not business logic",
      "Testability: ViewModel tests don't need to know about animations"
    ]
  },
  
  "error_handling": {
    "async_await": {
      "pattern": "func performAction() async {\n  do {\n    let result = try await useCase.execute()\n    await MainActor.run { status = .success(result) }\n  } catch let error as APIError {\n    await MainActor.run { status = .error(error.message) }\n  } catch {\n    await MainActor.run { status = .error(error.localizedDescription) }\n  }\n}"
    },
    "combine": {
      "pattern": "useCase.execute()\n  .sink(\n    receiveCompletion: { [weak self] completion in\n      if case .failure(let error) = completion {\n        self?.errorMessage = error.localizedDescription\n      }\n    },\n    receiveValue: { [weak self] result in\n      self?.data = result\n    }\n  )\n  .store(in: &cancellables)"
    }
  },
  
  "testing": {
    "viewmodel_tests": {
      "pattern": "class LoginViewModelTests: XCTestCase {\n  var viewModel: LoginViewModel!\n  var mockUseCase: MockLoginUseCase!\n  \n  override func setUp() {\n    mockUseCase = MockLoginUseCase()\n    viewModel = LoginViewModel(loginUseCase: mockUseCase)\n  }\n  \n  func testLoginSuccess() async {\n    mockUseCase.result = .success(User.mock)\n    await viewModel.login()\n    XCTAssertEqual(viewModel.status, .success(User.mock))\n  }\n}"
    }
  }
}
