{
  "$schema": "https://json-schema.org/draft-07/schema",
  "id": "ios.di.v3",
  "version": "3.0.0",
  
  "_note": "MVVM uses ViewModel init for feature dependencies, Resolver for global services",
  
  "framework": "Resolver",
  "alternative": "Swinject (if team prefers)",
  
  "viewmodel_init_pattern": {
    "description": "Primary DI for MVVM features - inject UseCases into ViewModel via init",
    "structure": "class LoginViewModel: ObservableObject {\n  @Published var email: String = \"\"\n  @Published var password: String = \"\"\n  @Published var status: Status = .idle\n  \n  // Dependencies\n  private let loginUseCase: LoginUserUseCaseProtocol\n  private let analyticsService: AnalyticsServiceProtocol\n  private let loggerService: LoggerServiceProtocol\n  private var cancellables = Set<AnyCancellable>()\n  \n  // Navigation callback (optional)\n  var onLoginSuccess: (() -> Void)?\n  \n  // Dependency injection via init\n  init(\n    loginUseCase: LoginUserUseCaseProtocol,\n    analyticsService: AnalyticsServiceProtocol,\n    loggerService: LoggerServiceProtocol\n  ) {\n    self.loginUseCase = loginUseCase\n    self.analyticsService = analyticsService\n    self.loggerService = loggerService\n  }\n  \n  // Convenience init for production (uses Resolver)\n  convenience init() {\n    self.init(\n      loginUseCase: Resolver.resolve(),\n      analyticsService: Resolver.resolve(),\n      loggerService: Resolver.resolve()\n    )\n  }\n}",
    "usage_in_view": "struct LoginView: View {\n  @StateObject private var viewModel = LoginViewModel()\n  \n  var body: some View {\n    TextField(\"Email\", text: $viewModel.email)\n    Button(\"Login\") {\n      Task { await viewModel.login() }\n    }\n  }\n}",
    "usage_in_coordinator": "class AuthCoordinator {\n  func showLogin() {\n    let viewModel = LoginViewModel(\n      loginUseCase: Resolver.resolve(),\n      analyticsService: Resolver.resolve(),\n      loggerService: Resolver.resolve()\n    )\n    viewModel.onLoginSuccess = { [weak self] in\n      self?.showHome()\n    }\n    \n    let view = LoginView(viewModel: viewModel)\n    // ... present view\n  }\n}"
  },
  
  "resolver_setup": {
    "description": "Resolver for global services and UseCases",
    "file": "Core/DI/DependencyContainer.swift",
    "registration": "extension Resolver: ResolverRegistering {\n  public static func registerAllServices() {\n    // MARK: - Core Services (Singleton)\n    register { APIClient() }.scope(.application)\n    register { KeychainService() }.scope(.application)\n    register { RealmService() }.scope(.application)\n    register { AnalyticsService() }.scope(.application)\n    register { LoggerService() }.scope(.application)\n    \n    // MARK: - Repositories (Singleton)\n    register { AuthRepository(\n      apiClient: resolve(),\n      keychainService: resolve()\n    ) as AuthRepositoryProtocol }.scope(.application)\n    \n    register { UserRepository(\n      apiClient: resolve(),\n      realmService: resolve()\n    ) as UserRepositoryProtocol }.scope(.application)\n    \n    // MARK: - UseCases (Factory - new instance per call)\n    register { LoginUserUseCase(\n      authRepository: resolve()\n    ) as LoginUserUseCaseProtocol }\n    \n    register { FetchUserProfileUseCase(\n      userRepository: resolve()\n    ) as FetchUserProfileUseCaseProtocol }\n  }\n}",
    "initialization": "// In AppDelegate or @main\nfunc application(_ application: UIApplication, didFinishLaunchingWithOptions...) -> Bool {\n  Resolver.registerAllServices()\n  return true\n}"
  },
  
  "scopes": {
    "application": {
      "description": "Singleton - one instance for app lifetime",
      "use_for": ["APIClient", "Services (Analytics, Logger, Keychain)", "Repositories"],
      "example": "register { APIClient() }.scope(.application)",
      "why": "Services and Repositories maintain state/connections, should be shared"
    },
    "cached": {
      "description": "Lazy init, cleared on memory warning",
      "use_for": ["Heavy objects with caching"],
      "example": "register { ImageCache() }.scope(.cached)",
      "why": "Performance optimization for expensive objects"
    },
    "shared": {
      "description": "New instance per resolution (default for UseCases)",
      "use_for": ["UseCases", "View-specific services"],
      "example": "register { LoginUserUseCase() }",
      "why": "UseCases are stateless, can be recreated each time"
    }
  },
  
  "dependency_flow": {
    "description": "How dependencies flow in MVVM architecture",
    "diagram": "Coordinator/View\n  └─> ViewModel.init() (uses Resolver.resolve())\n       └─> LoginUseCase: LoginUserUseCaseProtocol\n            └─> AuthRepository: AuthRepositoryProtocol\n                 └─> APIClient (from Resolver)",
    "example": "// 1. Resolver registers all services\nResolver.registerAllServices()\n\n// 2. View creates ViewModel using convenience init\nstruct LoginView: View {\n  @StateObject private var viewModel = LoginViewModel()  // Uses Resolver\n}\n\n// 3. Or Coordinator creates ViewModel with explicit dependencies\nlet viewModel = LoginViewModel(\n  loginUseCase: Resolver.resolve(),\n  analyticsService: Resolver.resolve(),\n  loggerService: Resolver.resolve()\n)\n\n// 4. ViewModel methods use injected dependencies\nfunc login() async {\n  status = .loading\n  do {\n    let user = try await loginUseCase.execute(\n      email: email,\n      password: password\n    )\n    status = .success(user)\n  } catch {\n    status = .error(error.localizedDescription)\n  }\n}"
  },
  
  "testing_pattern": {
    "description": "Use mock dependencies in ViewModel init for testing",
    "example": "// In tests\nfunc testLoginSuccess() async {\n  let mockUseCase = MockLoginUseCase()\n  mockUseCase.result = .success(User.mock)\n  \n  let viewModel = LoginViewModel(\n    loginUseCase: mockUseCase,\n    analyticsService: MockAnalyticsService(),\n    loggerService: MockLoggerService()\n  )\n  \n  await viewModel.login()\n  \n  XCTAssertEqual(viewModel.status, .success(User.mock))\n  XCTAssertTrue(mockUseCase.executeCalled)\n}"
  },
  
  "best_practices": {
    "rules": [
      "Use ViewModel init for feature dependencies (primary pattern)",
      "Use Resolver for global services (secondary pattern)",
      "Inject UseCases (NOT Repositories) into ViewModel",
      "Provide convenience init() that uses Resolver for production",
      "Always use full init with protocols for testing",
      "Register services .scope(.application) for singletons",
      "Register UseCases without scope (factory pattern)",
      "Use optional callbacks for navigation in ViewModel"
    ]
  },
  
  "anti_patterns": {
    "forbidden": [
      "DON'T inject Repositories directly into ViewModel (use UseCases)",
      "DON'T use global singletons (UserDefaults.standard) - inject via init",
      "DON'T create ViewModel without testable init (needs protocol dependencies)",
      "DON'T put UIKit/SwiftUI dependencies in ViewModel (except when necessary)",
      "DON'T register ViewModels in Resolver (Views create ViewModels directly)"
    ]
  }
}
