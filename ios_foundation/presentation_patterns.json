{
  "$schema": "https://json-schema.org/draft-07/schema",
  "id": "ios.presentation_patterns.v3",
  "version": "3.0.0",
  "last_updated": "2025-11-01",
  
  "primary_pattern": "MVVM (Model-View-ViewModel)",
  "_comment": "MVVM for AI-driven code generation. CRITICAL: Animation in @State (View), NOT ViewModel @Published",
  
  "mvvm_overview": {
    "description": "Model-View-ViewModel pattern with ObservableObject for reactive state management",
    "components": ["Model (Domain Entities)", "View (SwiftUI)", "ViewModel (ObservableObject)"],
    "data_flow": "User interaction → ViewModel method → Update @Published state → View refresh",
    "library": "Native Swift/Combine/SwiftUI (no external dependencies)",
    "benefits_for_ai": [
      "Simple structure (ViewModel + View, vs 5 TCA files)",
      "Observable state (@Published properties)",
      "Explicit methods (no Action enum to manage)",
      "Protocol-based dependencies (clear injection points)",
      "Testable with standard XCTest"
    ],
    "key_principle": "Animation state in @State (View), Business state in ViewModel @Published"
  },
  
  "viewmodel_component": {
    "definition": "class {Feature}ViewModel: ObservableObject",
    "purpose": "Manages business state and handles user actions",
    "must_rules": [
      "Be class conforming to ObservableObject",
      "Use @Published for business state properties",
      "Contain business state ONLY (no UI/animation transient state)",
      "Inject UseCases via init (NOT Repositories)",
      "Provide public methods for user actions"
    ],
    "must_not_rules": [
      "Contain animation values (CGFloat/Double/Angle)",
      "Contain transient UI state (@State-like properties)",
      "Import UIKit or SwiftUI (pure Swift + Combine only)",
      "Call Repositories directly (use UseCases)"
    ],
    "forbidden_properties": [
      "@Published var buttonScale: CGFloat",
      "@Published var dragOffset: CGPoint",
      "@Published var shakeOffset: Double",
      "@Published var animationProgress: Double"
    ],
    "correct_example": "import Foundation\\nimport Combine\\n\\nfinal class LoginViewModel: ObservableObject {\\n  // MARK: - Published State (Business State ONLY)\\n  @Published private(set) var email: String = \\\"\\\"\\n  @Published private(set) var password: String = \\\"\\\"\\n  @Published private(set) var status: Status = .idle\\n  @Published private(set) var errorMessage: String?\\n  \\n  enum Status: Equatable {\\n    case idle\\n    case loading\\n    case success(User)\\n    case error\\n  }\\n  \\n  // MARK: - Dependencies\\n  private let loginUseCase: LoginUserUseCaseProtocol\\n  private let analyticsService: AnalyticsServiceProtocol\\n  private var cancellables = Set<AnyCancellable>()\\n  \\n  // MARK: - Computed Properties\\n  var isLoading: Bool {\\n    if case .loading = status { return true }\\n    return false\\n  }\\n  \\n  var isFormValid: Bool {\\n    !email.isEmpty && email.contains(\\\"@\\\") && !password.isEmpty\\n  }\\n  \\n  // MARK: - Init\\n  init(\\n    loginUseCase: LoginUserUseCaseProtocol,\\n    analyticsService: AnalyticsServiceProtocol\\n  ) {\\n    self.loginUseCase = loginUseCase\\n    self.analyticsService = analyticsService\\n  }\\n  \\n  // MARK: - User Actions (Methods replace Action enum)\\n  func emailChanged(_ newEmail: String) {\\n    email = newEmail\\n  }\\n  \\n  func passwordChanged(_ newPassword: String) {\\n    password = newPassword\\n  }\\n  \\n  func loginButtonTapped() {\\n    guard isFormValid else {\\n      errorMessage = \\\"Invalid form\\\"\\n      return\\n    }\\n    \\n    status = .loading\\n    errorMessage = nil\\n    \\n    Task {\\n      do {\\n        let user = try await loginUseCase.execute(\\n          email: email,\\n          password: password\\n        )\\n        await MainActor.run {\\n          status = .success(user)\\n        }\\n        await analyticsService.track(event: .login)\\n      } catch {\\n        await MainActor.run {\\n          status = .error\\n          errorMessage = error.localizedDescription\\n        }\\n      }\\n    }\\n  }\\n}",
    "wrong_example": "// ❌ WRONG - Contains animation state\\nimport SwiftUI\\n\\nclass LoginViewModel: ObservableObject {\\n  @Published var email: String = \\\"\\\"\\n  @Published var buttonScale: CGFloat = 1.0  // ← FORBIDDEN\\n  @Published var shakeOffset: Double = 0     // ← FORBIDDEN\\n}"
  },
  
  "view_component": {
    "framework": "SwiftUI",
    "pattern": "@StateObject or @ObservedObject for ViewModel",
    "critical_rule": "Animation state in @State (View), Business state in ViewModel @Published",
    "must_rules": [
      "Use @StateObject (owner) or @ObservedObject (passed in) for ViewModel",
      "Use @State for UI/animation state (separate from ViewModel)",
      "Call ViewModel methods for user actions",
      "Observe ViewModel @Published properties directly",
      "Use .onChange(of:) to trigger animations"
    ],
    "must_not_rules": [
      "Contain business logic",
      "Call UseCases directly",
      "Put animation state in ViewModel @Published"
    ],
    "animation_pattern": {
      "principle": "Business state change → .onChange() → @State animation",
      "flow": "ViewModel @Published updates → View.onChange() detects → withAnimation {} updates @State → SwiftUI animates"
    },
    "example": "struct LoginView: View {\\n  @StateObject private var viewModel: LoginViewModel\\n  @Environment(\\\\.theme) var theme\\n  \\n  // ✅ Animation state in @State\\n  @State private var isShaking = false\\n  @State private var buttonScale: CGFloat = 1.0\\n  \\n  init(viewModel: LoginViewModel = LoginViewModel()) {\\n    _viewModel = StateObject(wrappedValue: viewModel)\\n  }\\n  \\n  var body: some View {\\n    VStack(spacing: 24) {\\n      TextField(\\\"Email\\\", text: .init(\\n        get: { viewModel.email },\\n        set: { viewModel.emailChanged($0) }\\n      ))\\n      \\n      SecureField(\\\"Password\\\", text: .init(\\n        get: { viewModel.password },\\n        set: { viewModel.passwordChanged($0) }\\n      ))\\n      \\n      Button(\\\"Login\\\") {\\n        viewModel.loginButtonTapped()\\n      }\\n      .scaleEffect(buttonScale)\\n      .disabled(viewModel.isLoading)\\n      .modifier(ShakeEffect(shakes: isShaking ? 3 : 0))\\n    }\\n    .padding()\\n    .background(theme.colors.background)\\n    // ✅ Business state → animation trigger\\n    .onChange(of: viewModel.status) { status in\\n      switch status {\\n      case .loading:\\n        withAnimation(.easeInOut(duration: 0.15)) {\\n          buttonScale = 0.95\\n        }\\n      case .error:\\n        buttonScale = 1.0\\n        withAnimation(.default) {\\n          isShaking = true\\n        }\\n        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {\\n          isShaking = false\\n        }\\n      case .success:\\n        buttonScale = 1.0\\n      case .idle:\\n        buttonScale = 1.0\\n      }\\n    }\\n  }\\n}"
  },
  
  "async_patterns": {
    "description": "Use async/await for asynchronous operations in ViewModel methods",
    "async_methods": {
      "when": "One-shot operations (login, fetch data, submit form)",
      "pattern": "func performAction() async {\\n  status = .loading\\n  do {\\n    let result = try await useCase.execute()\\n    await MainActor.run { status = .success(result) }\\n  } catch {\\n    await MainActor.run { status = .error }\\n  }\\n}",
      "view_call": "Button(\\\"Submit\\\") {\\n  Task { await viewModel.performAction() }\\n}"
    },
    "combine_publishers": {
      "when": "Reactive validation, debouncing, combining streams",
      "pattern": "private func setupBindings() {\\n  $searchText\\n    .debounce(for: 0.3, scheduler: DispatchQueue.main)\\n    .removeDuplicates()\\n    .sink { [weak self] text in\\n      self?.performSearch(text)\\n    }\\n    .store(in: &cancellables)\\n}"
    }
  },
  
  "navigation_patterns": {
    "description": "MVVM uses callbacks or @Published destination state for navigation",
    "callback_pattern": {
      "when": "Simple linear flows",
      "example": "class LoginViewModel: ObservableObject {\\n  var onLoginSuccess: ((User) -> Void)?\\n  var onCancel: (() -> Void)?\\n  \\n  func loginButtonTapped() async {\\n    // ... login logic\\n    if case .success(let user) = status {\\n      onLoginSuccess?(user)\\n    }\\n  }\\n}\\n\\n// In Coordinator\\nlet viewModel = LoginViewModel()\\nviewModel.onLoginSuccess = { [weak self] user in\\n  self?.showHome(user: user)\\n}"
    },
    "state_pattern": {
      "when": "Modals, sheets, alerts",
      "example": "@Published var destination: Destination?\\n\\nenum Destination: Identifiable {\\n  case taskDetail(SmartTask)\\n  case addTask\\n  \\n  var id: String {\\n    switch self {\\n    case .taskDetail(let task): return \\\"detail-\\\\(task.id)\\\"\\n    case .addTask: return \\\"add\\\"\\n    }\\n  }\\n}\\n\\n// In View\\n.sheet(item: $viewModel.destination) { destination in\\n  switch destination {\\n  case .taskDetail(let task):\\n    TaskDetailView(task: task)\\n  case .addTask:\\n    AddTaskView()\\n  }\\n}"
    },
    "coordinator_pattern": {
      "when": "Complex flows, deep linking",
      "example": "class AuthCoordinator {\\n  func showLogin() {\\n    let viewModel = LoginViewModel(\\n      loginUseCase: Resolver.resolve(),\\n      analyticsService: Resolver.resolve()\\n    )\\n    viewModel.onLoginSuccess = { [weak self] user in\\n      self?.showHome(user: user)\\n    }\\n    \\n    let view = LoginView(viewModel: viewModel)\\n    let vc = UIHostingController(rootView: view)\\n    navigationController.push(vc, animated: true)\\n  }\\n}"
    }
  },
  
  "dependency_injection": {
    "primary_pattern": "ViewModel init with protocol dependencies",
    "example": "class LoginViewModel: ObservableObject {\\n  private let loginUseCase: LoginUserUseCaseProtocol\\n  private let analyticsService: AnalyticsServiceProtocol\\n  \\n  init(\\n    loginUseCase: LoginUserUseCaseProtocol,\\n    analyticsService: AnalyticsServiceProtocol\\n  ) {\\n    self.loginUseCase = loginUseCase\\n    self.analyticsService = analyticsService\\n  }\\n  \\n  // Convenience init for production\\n  convenience init() {\\n    self.init(\\n      loginUseCase: Resolver.resolve(),\\n      analyticsService: Resolver.resolve()\\n    )\\n  }\\n}",
    "testing": "let mockUseCase = MockLoginUseCase()\\nlet viewModel = LoginViewModel(\\n  loginUseCase: mockUseCase,\\n  analyticsService: MockAnalyticsService()\\n)"
  },
  
  "ai_generation_checklist": {
    "viewmodel": [
      "✓ Is class conforming to ObservableObject",
      "✓ Uses @Published for business state ONLY",
      "✓ NO @Published for animations (CGFloat/Double/Angle)",
      "✓ Injects UseCases via init (NOT Repositories)",
      "✓ Provides public methods for user actions",
      "✓ Uses async methods for asynchronous operations",
      "✓ Provides convenience init() for production"
    ],
    "view": [
      "✓ Uses @StateObject for owned ViewModel",
      "✓ Uses @ObservedObject for passed ViewModel",
      "✓ Uses @State for animations/transient UI state",
      "✓ Calls ViewModel methods via Task for async",
      "✓ Uses .onChange(of: viewModel.property) for animations",
      "✓ NO business logic in View",
      "✓ NO animation state in ViewModel @Published"
    ]
  },
  
  "common_mistakes": [
    "❌ Putting animation state in ViewModel @Published (60fps jank)",
    "❌ Using @ObservedObject when View owns ViewModel (use @StateObject)",
    "❌ Not using weak self in closures (memory leaks)",
    "❌ Calling Repositories from ViewModel (use UseCases)",
    "❌ Forgetting to update @Published on MainActor in async methods"
  ]
}
