{
  "$schema": "https://json-schema.org/draft-07/schema",
  "id": "ios.testing.v3",
  "version": "3.0.0",
  
  "_note": "MVVM uses standard XCTest for ViewModel testing with mock dependencies",
  
  "unit_tests": {
    "framework": "XCTest",
    "naming": "{Feature}ViewModelTests.swift",
    "coverage_target": ">80%",
    "focus": ["ViewModels (primary)", "UseCases", "Repositories"],
    
    "viewmodel_tests": {
      "description": "Test ViewModels with mock dependencies",
      "import": "import XCTest\nimport Combine",
      "basic_pattern": "class LoginViewModelTests: XCTestCase {\n  var viewModel: LoginViewModel!\n  var mockUseCase: MockLoginUseCase!\n  var cancellables: Set<AnyCancellable>!\n  \n  override func setUp() {\n    mockUseCase = MockLoginUseCase()\n    viewModel = LoginViewModel(\n      loginUseCase: mockUseCase,\n      analyticsService: MockAnalyticsService(),\n      loggerService: MockLoggerService()\n    )\n    cancellables = []\n  }\n  \n  override func tearDown() {\n    cancellables = nil\n    viewModel = nil\n    mockUseCase = nil\n  }\n  \n  func testLoginSuccess() async {\n    mockUseCase.result = .success(User.mock)\n    \n    await viewModel.login()\n    \n    XCTAssertEqual(viewModel.status, .success(User.mock))\n    XCTAssertTrue(mockUseCase.executeCalled)\n    XCTAssertEqual(mockUseCase.callCount, 1)\n  }\n  \n  func testLoginFailure() async {\n    mockUseCase.result = .failure(APIError.unauthorized)\n    \n    await viewModel.login()\n    \n    if case .error(let message) = viewModel.status {\n      XCTAssertEqual(message, \"Unauthorized\")\n    } else {\n      XCTFail(\"Expected error status\")\n    }\n  }\n}",
      
      "testing_published_changes": {
        "description": "Test @Published property updates with Combine expectations",
        "example": "func testStatusChanges() {\n  let expectation = XCTestExpectation(description: \"Status changes to loading\")\n  \n  viewModel.$status\n    .dropFirst()  // Skip initial value\n    .sink { status in\n      if status == .loading {\n        expectation.fulfill()\n      }\n    }\n    .store(in: &cancellables)\n  \n  Task {\n    await viewModel.login()\n  }\n  \n  wait(for: [expectation], timeout: 1.0)\n}"
      },
      
      "testing_async_methods": {
        "description": "Test async ViewModel methods",
        "example": "func testLoadData() async throws {\n  mockUseCase.result = .success([1, 2, 3])\n  \n  await viewModel.loadData()\n  \n  XCTAssertEqual(viewModel.data, [1, 2, 3])\n  XCTAssertFalse(viewModel.isLoading)\n  XCTAssertNil(viewModel.errorMessage)\n}"
      },
      
      "testing_input_validation": {
        "description": "Test Combine-based validation",
        "example": "func testFormValidation() {\n  viewModel.email = \"invalid\"\n  viewModel.password = \"123\"\n  \n  XCTAssertFalse(viewModel.isFormValid)\n  \n  viewModel.email = \"test@test.com\"\n  viewModel.password = \"password123\"\n  \n  // Wait for Combine publishers to update\n  let expectation = XCTestExpectation(description: \"Form becomes valid\")\n  viewModel.$isFormValid\n    .dropFirst()\n    .sink { isValid in\n      if isValid {\n        expectation.fulfill()\n      }\n    }\n    .store(in: &cancellables)\n  \n  wait(for: [expectation], timeout: 1.0)\n}"
      }
    },
    
    "usecase_tests": {
      "description": "Test Domain layer UseCases independently",
      "example": "class LoginUserUseCaseTests: XCTestCase {\n  var useCase: LoginUserUseCase!\n  var mockRepository: MockAuthRepository!\n  \n  override func setUp() {\n    mockRepository = MockAuthRepository()\n    useCase = LoginUserUseCase(authRepository: mockRepository)\n  }\n  \n  func testExecuteSuccess() async throws {\n    mockRepository.loginResult = .success(User.mock)\n    \n    let user = try await useCase.execute(\n      email: \"test@test.com\",\n      password: \"password\"\n    )\n    \n    XCTAssertEqual(user.id, User.mock.id)\n    XCTAssertEqual(mockRepository.loginCallCount, 1)\n  }\n  \n  func testExecuteFailure() async {\n    mockRepository.loginResult = .failure(APIError.unauthorized)\n    \n    do {\n      _ = try await useCase.execute(\n        email: \"test@test.com\",\n        password: \"wrong\"\n      )\n      XCTFail(\"Should throw error\")\n    } catch {\n      XCTAssertEqual(error as? APIError, .unauthorized)\n    }\n  }\n}"
    }
  },
  
  "ui_tests": {
    "framework": "XCUITest",
    "naming": "{Feature}UITests.swift",
    "pattern": "Page Object Model",
    "note": "UI tests for MVVM views are standard SwiftUI tests",
    "example": "class LoginPage {\n  let app: XCUIApplication\n  \n  var emailField: XCUIElement { app.textFields[\"email\"] }\n  var passwordField: XCUIElement { app.secureTextFields[\"password\"] }\n  var loginButton: XCUIElement { app.buttons[\"login\"] }\n  var errorLabel: XCUIElement { app.staticTexts[\"error\"] }\n  \n  func login(email: String, password: String) {\n    emailField.tap()\n    emailField.typeText(email)\n    passwordField.tap()\n    passwordField.typeText(password)\n    loginButton.tap()\n  }\n}"
  },
  
  "mocking": {
    "protocol_based": "All dependencies as protocols for easy mocking",
    
    "mock_usecase": "class MockLoginUseCase: LoginUseCaseProtocol {\n  var result: Result<User, Error>!\n  var executeCalled = false\n  var callCount = 0\n  var lastEmail: String?\n  var lastPassword: String?\n  \n  func execute(email: String, password: String) async throws -> User {\n    executeCalled = true\n    callCount += 1\n    lastEmail = email\n    lastPassword = password\n    \n    switch result! {\n    case .success(let user): return user\n    case .failure(let error): throw error\n    }\n  }\n}",
    
    "mock_service": "class MockAnalyticsService: AnalyticsServiceProtocol {\n  var events: [AnalyticsEvent] = []\n  \n  func track(event: AnalyticsEvent) async {\n    events.append(event)\n  }\n}"
  },
  
  "test_data": {
    "description": "Provide mock data for testing",
    "example": "extension User {\n  static var mock: User {\n    User(\n      id: \"mock-id\",\n      email: \"test@test.com\",\n      name: \"Test User\"\n    )\n  }\n}"
  },
  
  "async_testing": {
    "description": "Testing async/await code in XCTest",
    "example": "func testAsyncOperation() async throws {\n  let result = try await someAsyncFunction()\n  XCTAssertEqual(result, expectedValue)\n}"
  },
  
  "best_practices": {
    "rules": [
      "Test ViewModels with mock dependencies",
      "Use async test functions (async throws)",
      "Test both success and failure paths",
      "Mock all dependencies via protocols",
      "Track mock call counts for verification",
      "Provide .mock static properties for test data",
      "Test UseCases independently from ViewModels",
      "Use Combine expectations for @Published testing"
    ]
  },
  
  "anti_patterns": {
    "forbidden": [
      "DON'T test only happy path (test error cases too)",
      "DON'T use real services in unit tests (slow, flaky)",
      "DON'T forget to assert mock call counts",
      "DON'T test UI animations (test business logic only)",
      "DON'T forget to clean up cancellables in tearDown"
    ]
  }
}
