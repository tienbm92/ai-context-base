{
  "$schema": "https://json-schema.org/draft-07/schema",
  "id": "ios.theme_system.v2",
  "version": "2.0.0",
  "last_updated": "2025-01-20",
  "platform": "iOS",
  
  "description": "Dynamic theme system for end-user personalization. Theme changes trigger app-wide style updates following MVVM architecture.",
  
  "architecture_integration": {
    "layer": "Presentation + Domain",
    "state_management": "AppViewModel @Published for theme selection",
    "ui_updates": "@Environment(\\.theme) for SwiftUI theme access",
    "persistence": "UserDefaults or Keychain for selected theme",
    "dependency_injection": "ThemeService injected via AppViewModel init"
  },
  
  "critical_rules": [
    "Theme state (selected theme ID) MUST be in AppViewModel @Published",
    "Theme animations (color transitions) MUST be in @State (View)",
    "Theme must be accessible globally via SwiftUI Environment",
    "Theme changes MUST be reversible (user can switch back)",
    "Default theme MUST always be available (fallback)"
  ],
  
  "mvvm_implementation": {
    "app_viewmodel": {
      "description": "AppViewModel holds global app state including theme",
      "definition": "class AppViewModel: ObservableObject {\n  @Published var currentThemeId: String = \"default_light\"\n  @Published var availableThemes: [String] = []\n  @Published var isLoadingTheme: Bool = false\n  \n  private let themeService: ThemeServiceProtocol\n  private var cancellables = Set<AnyCancellable>()\n  \n  init(themeService: ThemeServiceProtocol) {\n    self.themeService = themeService\n  }\n  \n  func loadSavedTheme() async {\n    let savedId = await themeService.loadSavedTheme()\n    currentThemeId = savedId\n  }\n  \n  func selectTheme(id: String) async {\n    isLoadingTheme = true\n    currentThemeId = id\n    await themeService.saveTheme(id: id)\n    isLoadingTheme = false\n  }\n  \n  func loadAvailableThemes() async {\n    availableThemes = await themeService.getAvailableThemes()\n  }\n}",
      "critical_note": "Only store themeId (String), not entire Theme object"
    },
    
    "app_view": {
      "description": "AppView provides theme via Environment based on AppViewModel.currentThemeId",
      "implementation": "struct AppView: View {\n  @StateObject private var appViewModel: AppViewModel\n  @StateObject private var themeService: ThemeService\n  \n  var body: some View {\n    ContentView()\n      .environment(\n        \\.theme,\n        themeService.getTheme(id: appViewModel.currentThemeId) ?? .defaultLight\n      )\n      .task {\n        await appViewModel.loadSavedTheme()\n        await appViewModel.loadAvailableThemes()\n      }\n  }\n}",
      "explanation": "Theme object passed down via SwiftUI Environment, themeId controlled by AppViewModel @Published"
    },
    
    "theme_aware_view": {
      "description": "Feature views access theme via @Environment",
      "example": "struct LoginView: View {\n  @StateObject private var viewModel: LoginViewModel\n  @Environment(\\.theme) var theme\n  \n  @State private var buttonScale: CGFloat = 1.0  // Animation state\n  \n  var body: some View {\n    VStack(spacing: 24) {\n      Text(\"Welcome\")\n        .font(theme.typography.h1)\n        .foregroundColor(theme.colors.textPrimary)\n      \n      Button(\"Login\") {\n        Task { await viewModel.login() }\n      }\n      .buttonStyle(ThemedButtonStyle(theme: theme))\n      .scaleEffect(buttonScale)\n    }\n    .background(theme.colors.background)\n  }\n}",
      "rules": [
        "Access theme via @Environment(\\.theme)",
        "Animation state in @State (NOT in ViewModel)",
        "Use theme colors/typography/spacing for consistent styling"
      ]
    },
    
    "theme_selection_view": {
      "description": "UI for selecting themes",
      "example": "struct ThemePickerView: View {\n  @EnvironmentObject var appViewModel: AppViewModel\n  @Environment(\\.theme) var currentTheme\n  \n  var body: some View {\n    List(appViewModel.availableThemes, id: \\.self) { themeId in\n      Button(themeId) {\n        Task { await appViewModel.selectTheme(id: themeId) }\n      }\n      .foregroundColor(\n        themeId == appViewModel.currentThemeId\n          ? currentTheme.colors.primary\n          : currentTheme.colors.textSecondary\n      )\n    }\n  }\n}"
    }
  },
  
  "theme_service": {
    "description": "Service for managing themes (load, save, get)",
    "protocol": "protocol ThemeServiceProtocol {\n  func getTheme(id: String) -> Theme?\n  func getAvailableThemes() async -> [String]\n  func loadSavedTheme() async -> String\n  func saveTheme(id: String) async\n}",
    "implementation": "class ThemeService: ObservableObject, ThemeServiceProtocol {\n  private var themes: [String: Theme] = [:]\n  private let storage: UserDefaults\n  \n  init(storage: UserDefaults = .standard) {\n    self.storage = storage\n    loadThemes()\n  }\n  \n  func getTheme(id: String) -> Theme? {\n    themes[id]\n  }\n  \n  func getAvailableThemes() async -> [String] {\n    Array(themes.keys)\n  }\n  \n  func loadSavedTheme() async -> String {\n    storage.string(forKey: \"selected_theme\") ?? \"default_light\"\n  }\n  \n  func saveTheme(id: String) async {\n    storage.set(id, forKey: \"selected_theme\")\n  }\n}"
  },
  
  "theme_animation": {
    "description": "How to animate theme transitions",
    "correct_pattern": {
      "viewmodel": "@Published var currentThemeId: String = \"default_light\"  // Business state",
      "view": "@State private var colorTransition: Double = 0.0  // Animation state\n\n.onChange(of: appViewModel.currentThemeId) { _ in\n  withAnimation(.easeInOut(duration: 0.3)) {\n    colorTransition = 1.0\n  }\n}",
      "why": "Theme ID changes trigger color transition animation in View"
    }
  },
  
  "best_practices": [
    "Store only theme ID in AppViewModel @Published",
    "Theme object accessed via @Environment(\\.theme)",
    "Theme Service manages theme loading/saving",
    "Animate theme transitions with @State in View",
    "Provide default theme as fallback",
    "Use ThemeService protocol for testability"
  ]
}
