{
  "$schema": "https://json-schema.org/draft-07/schema",
  "id": "ios.theme_system.v2",
  "version": "2.0.0",
  "last_updated": "2025-01-20",
  "platform": "iOS",
  
  "description": "Dynamic theme system for end-user personalization with Liquid Glass support (iOS 26+). Theme changes trigger app-wide style updates following MVVM architecture.",
  
  "architecture_integration": {
    "layer": "Presentation + Domain",
    "state_management": "AppViewModel @Published for theme selection",
    "ui_updates": "@Environment(\\.theme) for SwiftUI theme access",
    "persistence": "UserDefaults or Keychain for selected theme",
    "dependency_injection": "ThemeService injected via AppViewModel init",
    "liquid_glass": "Theme provides Liquid Glass material configuration per appearance"
  },
  
  "critical_rules": [
    "Theme state (selected theme ID) MUST be in AppViewModel @Published",
    "Theme animations (color transitions) MUST be in @State (View)",
    "Theme must be accessible globally via SwiftUI Environment",
    "Theme changes MUST be reversible (user can switch back)",
    "Default theme MUST always be available (fallback)"
  ],
  
  "mvvm_implementation": {
    "app_viewmodel": {
      "description": "AppViewModel holds global app state including theme",
      "definition": "class AppViewModel: ObservableObject {\n  @Published var currentThemeId: String = \"default_light\"\n  @Published var availableThemes: [String] = []\n  @Published var isLoadingTheme: Bool = false\n  \n  private let themeService: ThemeServiceProtocol\n  private var cancellables = Set<AnyCancellable>()\n  \n  init(themeService: ThemeServiceProtocol) {\n    self.themeService = themeService\n  }\n  \n  func loadSavedTheme() async {\n    let savedId = await themeService.loadSavedTheme()\n    currentThemeId = savedId\n  }\n  \n  func selectTheme(id: String) async {\n    isLoadingTheme = true\n    currentThemeId = id\n    await themeService.saveTheme(id: id)\n    isLoadingTheme = false\n  }\n  \n  func loadAvailableThemes() async {\n    availableThemes = await themeService.getAvailableThemes()\n  }\n}",
      "critical_note": "Only store themeId (String), not entire Theme object"
    },
    
    "app_view": {
      "description": "AppView provides theme via Environment based on AppViewModel.currentThemeId",
      "implementation": "struct AppView: View {\n  @StateObject private var appViewModel: AppViewModel\n  @StateObject private var themeService: ThemeService\n  \n  var body: some View {\n    ContentView()\n      .environment(\n        \\.theme,\n        themeService.getTheme(id: appViewModel.currentThemeId) ?? .defaultLight\n      )\n      .task {\n        await appViewModel.loadSavedTheme()\n        await appViewModel.loadAvailableThemes()\n      }\n  }\n}",
      "explanation": "Theme object passed down via SwiftUI Environment, themeId controlled by AppViewModel @Published"
    },
    
    "theme_aware_view": {
      "description": "Feature views access theme via @Environment",
      "example": "struct LoginView: View {\n  @StateObject private var viewModel: LoginViewModel\n  @Environment(\\.theme) var theme\n  \n  @State private var buttonScale: CGFloat = 1.0  // Animation state\n  \n  var body: some View {\n    VStack(spacing: 24) {\n      Text(\"Welcome\")\n        .font(theme.typography.h1)\n        .foregroundColor(theme.colors.textPrimary)\n      \n      Button(\"Login\") {\n        Task { await viewModel.login() }\n      }\n      .buttonStyle(ThemedButtonStyle(theme: theme))\n      .scaleEffect(buttonScale)\n    }\n    .background(theme.colors.background)\n  }\n}",
      "rules": [
        "Access theme via @Environment(\\.theme)",
        "Animation state in @State (NOT in ViewModel)",
        "Use theme colors/typography/spacing for consistent styling"
      ]
    },
    
    "theme_selection_view": {
      "description": "UI for selecting themes",
      "example": "struct ThemePickerView: View {\n  @EnvironmentObject var appViewModel: AppViewModel\n  @Environment(\\.theme) var currentTheme\n  \n  var body: some View {\n    List(appViewModel.availableThemes, id: \\.self) { themeId in\n      Button(themeId) {\n        Task { await appViewModel.selectTheme(id: themeId) }\n      }\n      .foregroundColor(\n        themeId == appViewModel.currentThemeId\n          ? currentTheme.colors.primary\n          : currentTheme.colors.textSecondary\n      )\n    }\n  }\n}"
    }
  },
  
  "theme_service": {
    "description": "Service for managing themes (load, save, get)",
    "protocol": "protocol ThemeServiceProtocol {\n  func getTheme(id: String) -> Theme?\n  func getAvailableThemes() async -> [String]\n  func loadSavedTheme() async -> String\n  func saveTheme(id: String) async\n}",
    "implementation": "class ThemeService: ObservableObject, ThemeServiceProtocol {\n  private var themes: [String: Theme] = [:]\n  private let storage: UserDefaults\n  \n  init(storage: UserDefaults = .standard) {\n    self.storage = storage\n    loadThemes()\n  }\n  \n  func getTheme(id: String) -> Theme? {\n    themes[id]\n  }\n  \n  func getAvailableThemes() async -> [String] {\n    Array(themes.keys)\n  }\n  \n  func loadSavedTheme() async -> String {\n    storage.string(forKey: \"selected_theme\") ?? \"default_light\"\n  }\n  \n  func saveTheme(id: String) async {\n    storage.set(id, forKey: \"selected_theme\")\n  }\n}"
  },
  
  "theme_animation": {
    "description": "How to animate theme transitions",
    "correct_pattern": {
      "viewmodel": "@Published var currentThemeId: String = \"default_light\"  // Business state",
      "view": "@State private var colorTransition: Double = 0.0  // Animation state\n\n.onChange(of: appViewModel.currentThemeId) { _ in\n  withAnimation(.easeInOut(duration: 0.3)) {\n    colorTransition = 1.0\n  }\n}",
      "why": "Theme ID changes trigger color transition animation in View"
    }
  },
  
  "best_practices": [
    "Store only theme ID in AppViewModel @Published",
    "Theme object accessed via @Environment(\\.theme)",
    "Theme Service manages theme loading/saving",
    "Animate theme transitions with @State in View",
    "Provide default theme as fallback",
    "Use ThemeService protocol for testability",
    "Use Liquid Glass button styles (.glass, .glassProminent) with themes",
    "Theme should provide Liquid Glass material configuration"
  ],
  
  "liquid_glass_integration": {
    "description": "iOS 26+ Liquid Glass material integration with theme system",
    "theme_appearances": {
      "default_light": "Standard Liquid Glass with light theme colors",
      "default_dark": "Standard Liquid Glass with dark theme colors",
      "clear_light": "Elegant transparent appearance with light tints",
      "clear_dark": "Elegant transparent appearance with dark tints",
      "tinted_light": "Colorful tinted Liquid Glass (light)",
      "tinted_dark": "Colorful tinted Liquid Glass (dark)"
    },
    "theme_structure_with_liquid_glass": {
      "description": "Theme object should include Liquid Glass material configuration",
      "example": "struct Theme {\n  let id: String\n  let name: String\n  let appearance: Appearance\n  let colors: ColorPalette\n  let typography: Typography\n  let spacing: Spacing\n  let liquidGlass: LiquidGlassMaterial  // NEW for iOS 26+\n  \n  enum Appearance {\n    case light\n    case dark\n    case clearLight\n    case clearDark\n    case tintedLight(Color)\n    case tintedDark(Color)\n  }\n}\n\nstruct LiquidGlassMaterial {\n  let blurRadius: CGFloat\n  let opacity: Double\n  let tintColor: Color?\n  let reflectionIntensity: Double\n  let refractionIntensity: Double\n}"
    },
    "applying_liquid_glass_with_theme": {
      "description": "Use theme Liquid Glass configuration in Views",
      "button_example": "Button(\"Submit\") {\n  viewModel.submit()\n}\n.buttonStyle(.glass)\n// System automatically adapts to current theme appearance",
      "custom_control_example": "RoundedRectangle(cornerRadius: theme.liquidGlass.cornerRadius)\n  .fill(.clear)\n  .glassEffect(\n    .regularMaterial,\n    in: RoundedRectangle(cornerRadius: theme.liquidGlass.cornerRadius)\n  )\n  .opacity(theme.liquidGlass.opacity)",
      "critical_note": "Liquid Glass material automatically adapts to theme appearance (light/dark/tinted)"
    },
    "app_icon_theming": {
      "description": "iOS 26+ app icons support theme appearances",
      "supported_appearances": [
        "Default (light) - icon designed for light backgrounds",
        "Dark - icon optimized for dark backgrounds",
        "Clear (light/dark) - elegant transparent look",
        "Tinted (light/dark) - colorful personalized appearance"
      ],
      "implementation": "Use Icon Composer to create layered icons that automatically adapt to user's selected appearance"
    },
    "seasonal_themes_with_liquid_glass": {
      "description": "Create themed experiences with Liquid Glass for holidays/events",
      "examples": [
        {
          "theme": "Christmas",
          "liquid_glass_tint": "Red/Green gradient",
          "appearance": "tintedLight or tintedDark"
        },
        {
          "theme": "Lunar New Year",
          "liquid_glass_tint": "Gold/Red",
          "appearance": "tintedLight"
        },
        {
          "theme": "Halloween",
          "liquid_glass_tint": "Orange/Purple",
          "appearance": "tintedDark"
        }
      ],
      "implementation": "Theme service provides Liquid Glass tint based on selected theme ID"
    },
    "migration_from_ios_18_themes": {
      "step_1": "Add LiquidGlassMaterial struct to Theme definition",
      "step_2": "Update ThemeService to provide Liquid Glass configuration per theme",
      "step_3": "Replace custom button styles with .glass/.glassProminent where appropriate",
      "step_4": "Let system components automatically adopt Liquid Glass (rebuild with Xcode)",
      "step_5": "Update app icons using Icon Composer to support theme appearances"
    }
  }
}
